<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Beginning Swift Programming Part 9 — Basic Protocols, Extensions, and Subscripts</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Beginning Swift Programming Part 9 — Basic Protocols, Extensions, and Subscripts</h1>
</header>
<section data-field="subtitle" class="p-summary">
In the last post, we covered typecasting, safely unwrapping optionals, and access controls.
</section>
<section data-field="body" class="e-content">
<section name="e50c" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="2a63" id="2a63" class="graf graf--h3 graf--leading graf--title">Beginning Swift Programming Part 9 — Basic Protocols, Extensions, and Subscripts</h3><figure name="4443" id="4443" class="graf graf--figure graf-after--h3"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 393px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 56.2%;"></div><img class="graf-image" data-image-id="0*KXfxGx_KucGCu4Es." data-width="4912" data-height="2760" src="https://cdn-images-1.medium.com/max/800/0*KXfxGx_KucGCu4Es."></div><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/@antoine_schibler?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com/@antoine_schibler?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-creator noopener" target="_blank">Antoine Schibler</a> on <a href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-source noopener" target="_blank">Unsplash</a></figcaption></figure><p name="103f" id="103f" class="graf graf--p graf-after--figure">In the last post, we covered typecasting, safely unwrapping optionals, and access controls.</p><div name="927f" id="927f" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://medium.com/@broebling/beginning-swift-programming-part-8-type-casting-safely-unwrapping-optionals-and-access-control-179c28b19a5e" data-href="https://medium.com/@broebling/beginning-swift-programming-part-8-type-casting-safely-unwrapping-optionals-and-access-control-179c28b19a5e" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.com/@broebling/beginning-swift-programming-part-8-type-casting-safely-unwrapping-optionals-and-access-control-179c28b19a5e"><strong class="markup--strong markup--mixtapeEmbed-strong">Beginning Swift Programming Part 8 — Type Casting, Safely Unwrapping Optionals, and Access Control</strong><br><em class="markup--em markup--mixtapeEmbed-em">In the last post, we talked about initialization, deinitialization, overrides, and reference counting.</em>medium.com</a><a href="https://medium.com/@broebling/beginning-swift-programming-part-8-type-casting-safely-unwrapping-optionals-and-access-control-179c28b19a5e" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="f98afff84bdd827d5b03bef8342cef4b" data-thumbnail-img-id="0*8e51xdxq7O9M0vH2." style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*8e51xdxq7O9M0vH2.);"></a></div><p name="078d" id="078d" class="graf graf--p graf-after--mixtapeEmbed">It wasn’t anything hard, maybe moderate at best for some of you because with the concept of access control. This post might ramp things up again, but again it’s only because of practical application use cases.</p><p name="148e" id="148e" class="graf graf--p graf-after--p">I will try my best to explain things in a way that will help you make sense of it all and when and where you should use each topic covered. I know that some tutorials jump right in and bring up extensions, but I won’t. Extensions are a building block to do more with what you already know and because of that very reason, I decided it would be better to start you off with protocols. So let’s dig in.</p><h3 name="cc78" id="cc78" class="graf graf--h3 graf-after--p">Protocols</h3><p name="2db0" id="2db0" class="graf graf--p graf-after--h3">Ok, so both protocol and extension sound daunting and the definitions provided by Apple do not clear up the muddy water when you are starting off.</p><p name="f833" id="f833" class="graf graf--p graf-after--p">This definition is straight from <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html" data-href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Apple’s book</a>:</p><blockquote name="797f" id="797f" class="graf graf--pullquote graf-after--p">A <em class="markup--em markup--pullquote-em">protocol</em> defines a blueprint of methods, properties, and other requirements that suit a particular task or piece of functionality. The protocol can then be <em class="markup--em markup--pullquote-em">adopted</em> by a class, structure, or enumeration to provide an actual implementation of those requirements. Any type that satisfies the requirements of a protocol is said to <em class="markup--em markup--pullquote-em">conform</em> to that protocol.</blockquote><p name="660c" id="660c" class="graf graf--p graf-after--pullquote">Some of you may have understood that right away, others might still be scratching your head over it. Don’t worry about it, and for now, let’s just forget that definition for the moment, I have an explanation using Baseball to guide us through it.</p><p name="b54a" id="b54a" class="graf graf--p graf-after--p">In Baseball we have different positions such as batters, pitchers, catchers, basemen, outfielders, coaches, and umpires. If you know anything about baseball you would know that each person on the team has a role to fill and each person excels at that role. We can’t just take a third baseman and make them a pitcher, or take an umpire and make them an outfielder. The first scenario would be hard because teams like to hire left-handers for the first basemen and right-handers for third base. The other doesn’t seem like a good idea because the umpire is neutral between the two teams.</p><p name="aa32" id="aa32" class="graf graf--p graf-after--p">If each player was a class, <em class="markup--em markup--p-em">how</em> they play the game is defined by a protocol. Let’s see how this looks in code.</p><figure name="c6ce" id="c6ce" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/mildocjr/be6aa87a39e450150d97183bfca5f691.js"></script></figure><p name="bd20" id="bd20" class="graf graf--p graf-after--figure">I added a little extra here so you can follow how it came to be. First, we define enums to define pitching styles. Then we define a protocol. The protocol is for the Pitcher position and defines possible methods and a property, pitchers would find useful. Below that, I create a Pitcher struct that we can use to create Pitchers for our game, Inside the struct contains all of the methods and properties that pitchers would need to play our game correctly.</p><p name="fe01" id="fe01" class="graf graf--p graf-after--p">But you doubled up on code, yes I did, but this ensures that anyone else working on my code is <em class="markup--em markup--p-em">required</em> to include these methods and property when adopting the protocol. It makes sure that any pitcher who adopts from the pitcher protocol can still do their job, pitch!</p><p name="3cbb" id="3cbb" class="graf graf--p graf-after--p">While that doesn’t really seem like anything useful, protocols in this form are perfect for large teams. Because no one else on your team knows what the use case for a class is when you just call it <code class="markup--code markup--p-code">JSONManager</code>. Ok, so does this take JSON data and format it? Does it save it somewhere? What does it do? well if I wrote the class declaration as</p><p name="4e9e" id="4e9e" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">JSONManager: Downloadable, Uploadable, Storable, Retrievable</code></p><p name="2804" id="2804" class="graf graf--p graf-after--p">What does this declaration tell you? Well for me it says JSONManager can <strong class="markup--strong markup--p-strong">download</strong> JSON, <strong class="markup--strong markup--p-strong">upload</strong> JSON, <strong class="markup--strong markup--p-strong">store</strong> JSON somewhere, or <strong class="markup--strong markup--p-strong">retrieve</strong> JSON from wherever it’s stored. We don’t care where it’s getting or putting the data, we only care that <code class="markup--code markup--p-code">JSONManager</code> is going to help us get it. This is called abstraction. Even better, what if I had another class someone else created<code class="markup--code markup--p-code">DataManager</code>. It could adopt all or some of these protocols and I’m sure that whatever protocols it adopted from, I can expect to get data from it.</p><p name="3807" id="3807" class="graf graf--p graf-after--p">So when I first started writing the example above, I didn’t start with the enums at the top, I actually started with the protocol.</p><p name="6430" id="6430" class="graf graf--p graf-after--p">I thought, “I need a Pitcher for this game”. <br>I typed <code class="markup--code markup--p-code">protocol Pitcher {}</code>. <br>I then thought, “What all does a pitcher do in Baseball?”<br>easy they throw the ball so I wrote <code class="markup--code markup--p-code">func throwBall(</code>… <br>“Nah, that’s too simple, I need different pitching types.” <br>So I continued <code class="markup--code markup--p-code">func throwBall(with:</code>.<br> “Hmm, do I want to pass in a string or become more type-safe by using an enum?”<br>So I wrote <code class="markup--code markup--p-code">enum PitchStyle { ... }</code>.<br>I finished the function <code class="markup--code markup--p-code">func throwBall(with: PitchStyle)</code>.<br>“But don’t pitchers throw bad pitches every once in a while?”<br>They sure do! <code class="markup--code markup--p-code">enum BadPitchStyle { ... }</code>.<br>And add a function for that <code class="markup--code markup--p-code">func throwBadPitch(with: BadPitchStyle)</code><br>“Hmm, how do I determine when to throw a bad pitch?” <br><code class="markup--code markup--p-code">var energy: Int</code></p><p name="a427" id="a427" class="graf graf--p graf-after--p">Using this logic I was able to come up with the protocol that would later define how my pitcher classes would work.</p><p name="716b" id="716b" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">Apple even says “first, start with a protocol.”</em> — I mentioned this <a href="https://medium.com/@broebling/programming-patterns-in-swift-5bcd7b77c660" data-href="https://medium.com/@broebling/programming-patterns-in-swift-5bcd7b77c660" class="markup--anchor markup--p-anchor" target="_blank">in my first post</a> unrelated to this series and it’s worth mentioning again.</p><p name="9abb" id="9abb" class="graf graf--p graf-after--p">Starting with a protocol may seem tedious and boring because you don’t get instant results, but it allows you to figure out what all properties and methods are needed for your class or struct to perform work. It’s like doing the analysis before you start coding. If you mess up, it’s not that hard to fix. You just rename the method or property in your protocol and you are done in a few, if not one, lines.</p><p name="93fe" id="93fe" class="graf graf--p graf-after--p">But Bob, there’s only one pitcher on a team, and I could reuse this same struct to create both pitchers. Yes you are right, but at least we restricted these methods only to pitchers. Let’s see how you might do this for the outfielders.</p><figure name="3010" id="3010" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/mildocjr/a2ef2be1e1d14eb848898e3e4fbc361e.js"></script></figure><p name="c813" id="c813" class="graf graf--p graf-after--figure">So you see, protocols can force you to use the right code no matter how many times you use it. It keeps you and your team honest. But let’s see how we can supercharge protocols by extending them.</p><figure name="8533" id="8533" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 467px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 66.7%;"></div><img class="graf-image" data-image-id="0*82mgqdbk8xiouHcB." data-width="5184" data-height="3456" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*82mgqdbk8xiouHcB."></div><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/@timothyeberly?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com/@timothyeberly?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-creator noopener" target="_blank">Timothy Eberly</a> on <a href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-source noopener" target="_blank">Unsplash</a></figcaption></figure><h3 name="6502" id="6502" class="graf graf--h3 graf-after--figure">Extensions</h3><p name="bb03" id="bb03" class="graf graf--p graf-after--h3">Extensions are given a big name for a simple concept. Extensions essentially extend functionality to a class, struct, or protocol. In terms of how they are used, I’m going to reference the Foundation library in Swift. Foundation has a class named <code class="markup--code markup--p-code">UITableView</code>. <code class="markup--code markup--p-code">UITableView</code> on its own only handles displaying table views. However, we can extend its functionality by giving it an extension named <code class="markup--code markup--p-code">UITableViewDataSource</code>. This provides the class that is adopting this protocol the ability to provide the context of how the data is displayed inside of the table view.</p><p name="d46f" id="d46f" class="graf graf--p graf-after--p">The picture above is a good example of an extension.</p><figure name="f0e1" id="f0e1" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/mildocjr/82d35d33f1f6e9206991ef90aed5f1bf.js"></script></figure><p name="ca8a" id="ca8a" class="graf graf--p graf-after--figure">Of course, it doesn’t <em class="markup--em markup--p-em">need</em> to adopt another class, it could just be for separating pieces of code from each other in a logical way.</p><figure name="f619" id="f619" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/mildocjr/eed1528daa81945061b9d19220ca1cae.js"></script></figure><p name="5322" id="5322" class="graf graf--p graf-after--figure">Now while this may seem a little overkill, you can use comments to separate your code into logical pieces by using <code class="markup--code markup--p-code">//MARK: title of section</code>. You can also navigate through your code using these marks in the breadcrumb at the top of the Xcode editor window.</p><figure name="d1fb" id="d1fb" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 582px; max-height: 62px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 10.7%;"></div><img class="graf-image" data-image-id="1*EHCG3qxDV92491e2jiORjg.png" data-width="582" data-height="62" src="https://cdn-images-1.medium.com/max/800/1*EHCG3qxDV92491e2jiORjg.png"></div></figure><p name="10be" id="10be" class="graf graf--p graf-after--figure">By clicking on “No Selection” You open up a tree of your current layout.</p><figure name="bfdc" id="bfdc" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 508px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 72.5%;"></div><img class="graf-image" data-image-id="1*2Kjy1PxA70tEguzXLzMsWw.png" data-width="750" data-height="544" src="https://cdn-images-1.medium.com/max/800/1*2Kjy1PxA70tEguzXLzMsWw.png"></div></figure><p name="e085" id="e085" class="graf graf--p graf-after--figure">This allows you to navigate through your code by clicking on any part of the tree and Xcode will focus on that code. By using <code class="markup--code markup--p-code">//MARK: — Properties</code> you can create a horizontal line above Properties, like-wise you can use <br><code class="markup--code markup--p-code">//MARK: Properties —</code> to place a horizontal line below properties. Or you can have one both above and below but I typically just leave one above to split it out into sections like this. It’s your choice on what makes the most sense to you. <a href="https://developer.apple.com/library/content/documentation/Xcode/Reference/xcode_markup_formatting_ref/" data-href="https://developer.apple.com/library/content/documentation/Xcode/Reference/xcode_markup_formatting_ref/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">For more info check out Apple’s markup documentation</a>.</p><p name="1c3e" id="1c3e" class="graf graf--p graf-after--p">OK, just a tip I thought I’d leave here, back to extensions. Aside from splitting your code up into logical areas, they do something else that became the reason I became a protocol fanatic and try to use them whenever I can.</p><p name="d25d" id="d25d" class="graf graf--p graf-after--p">So Protocols are awesome for teams, that is apparent from the start, but you might be asking yourself why you would ever use protocols if you are a solo developer? You know what everything does and you don’t mind getting a refresher when you come back to your code in a year to post an update. Especially if it means having to write more code that isn’t really important for your app to function.</p><p name="cab2" id="cab2" class="graf graf--p graf-after--p">Remember that <code class="markup--code markup--p-code">Fielder</code> protocol? &lt;Enter Morpheus&gt; What if I told you that you didn’t have to write the protocol requirements, that you didn’t have to click the red stop sign to have it implement every method stub in every occurrence where the protocol is used. Would you like protocols then?</p><p name="120e" id="120e" class="graf graf--p graf-after--p">The sheer fact that in the example above, I’d have you write 6 properties and 4 methods 7 times with darn near the same implementation would be insane, that’s 42 properties, and 28 methods, not to mention the logic involved in each method. Sounds like torture to me.</p><p name="8698" id="8698" class="graf graf--p graf-after--p">Extensions + Protocols = ❤… or a superhero if you’d rather go with that.</p><p name="10ad" id="10ad" class="graf graf--p graf-after--p">So let’s see what I’m talking about, I’ll just do some copy-pasta from above so we don’t need to scroll up.</p><figure name="b55f" id="b55f" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/mildocjr/ff6caa572061e07fe3c0edd3e3b8d857.js"></script></figure><p name="5edc" id="5edc" class="graf graf--p graf-after--figure">I’m not going to go over how the protocol is made, but I will talk about the protocol’s extension. The extension defines default values for everything that adopts from the <code class="markup--code markup--p-code">Fielder</code> protocol. This means because the method has a variable, we do not need to include its implementation in every single object that is a <code class="markup--code markup--p-code">Fielder</code>. We only had to type it once and we’re done. This means that if we were to create another position called <code class="markup--code markup--p-code">Catcher</code>, all we would need to do is have it adopt from <code class="markup--code markup--p-code">Fielder</code> and it gets all of the default property values and methods. We would only need to implement non-optional properties not set in the protocol extension.</p><p name="0efb" id="0efb" class="graf graf--p graf-after--p">So if we think about the JSON example I gave you previously, we could create extensions for each of those protocols that <code class="markup--code markup--p-code">JSONManager</code> or <code class="markup--code markup--p-code">DataManager</code> adopted and include them with new classes without writing any extra code other than what we needed to handle what was specific to that class or struct.</p><figure name="fb10" id="fb10" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 467px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 66.7%;"></div><img class="graf-image" data-image-id="0*-qht5D1Pi0aBh3p4." data-width="5783" data-height="3855" src="https://cdn-images-1.medium.com/max/800/0*-qht5D1Pi0aBh3p4."></div><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/@chriskristiansen?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com/@chriskristiansen?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-creator noopener" target="_blank">Chris Kristiansen</a> on <a href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-source noopener" target="_blank">Unsplash</a></figcaption></figure><h3 name="bb81" id="bb81" class="graf graf--h3 graf-after--figure">Subscripts</h3><p name="4fad" id="4fad" class="graf graf--p graf-after--h3">Moving on to subscripts, this should be pretty easy as we already talked about it with Arrays and Dictionaries. A subscript is just a fancy way of saying index. You can subscript arrays by using <code class="markup--code markup--p-code">myArray[0]</code> to get the first element of that array.</p><p name="e90c" id="e90c" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">If you didn’t know, arrays are zero-based because in the old days, arrays were reference types and the 0 referred to how many places away from the start, or head, of the array the element was positioned.</em></p><p name="2271" id="2271" class="graf graf--p graf-after--p">Dictionaries use subscripts using their keys. <code class="markup--code markup--p-code">myMovies[“gotg1”]</code> might reference the value <br><code class="markup--code markup--p-code">“Gaurdians of the Galaxy Part 1”</code>. We just used a subscript on the key to retrieve the value. So like I said, nothing new except the name.</p><p name="9ff2" id="9ff2" class="graf graf--p graf-after--p">Where subscripts get interesting is when you start realizing you can use subscripts in a matrix. Let’s take a look.</p><figure name="d286" id="d286" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/mildocjr/8c75a8cf49fa9ed3c05a2442ff2d1821.js"></script></figure><p name="9743" id="9743" class="graf graf--p graf-after--figure">How would you even go about referencing these? The syntax looks like this:</p><figure name="24e7" id="24e7" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/mildocjr/7cf6144eba094cdb7edaeb531675bb5a.js"></script></figure><p name="f206" id="f206" class="graf graf--p graf-after--figure">If you wanted to look at every value you could double up on for-in loops like this:</p><figure name="98dd" id="98dd" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/mildocjr/87e7547d1129e096bf01f8556bbf9b1f.js"></script></figure><p name="77c9" id="77c9" class="graf graf--p graf-after--figure">So subscripting is pretty straightforward, just use the index of whatever value you are looking for and with matrices, it’s best to look at them like <br><code class="markup--code markup--p-code">[ [ [value] ] ]</code> then work your way from <strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">outside to inside</em></strong> to get the value you are looking for.</p><p name="f689" id="f689" class="graf graf--p graf-after--p">Unfortunately, I’m out of tips and tricks for working with a matrix, you’ll get the hang of it with plenty of <strong class="markup--strong markup--p-strong">practice</strong> and <strong class="markup--strong markup--p-strong">experience</strong>. It just comes with the territory of being a developer.</p><h3 name="4b68" id="4b68" class="graf graf--h3 graf-after--p">Summary</h3><p name="5ab5" id="5ab5" class="graf graf--p graf-after--h3">So we learned quite a lot of helpful stuff today. We helped your code become more defined using protocols, more readable with extensions, and more reusable by using both together! Then we wrapped it up with a short extra on subscripts that ended up being focused in on matrices.</p><p name="8cab" id="8cab" class="graf graf--p graf-after--p">First, start with a protocol! Use extensions with protocols to reduce the amount of code you have to write. Use extensions to split a large class into two files. If you forget everything else from this post, remember those three things.</p><h3 name="8f02" id="8f02" class="graf graf--h3 graf-after--p">What’s Next</h3><p name="e1e1" id="e1e1" class="graf graf--p graf-after--h3">OK, I’m really dreading talking about closures, while I understand them, there are facets of closures that I’m still wrapping my head around, but only in the most complex situations. So you’ll be happy to know that my next post will not be about closures, but will be about making your code more readable, easy to understand, and I’ll almost certainly be using real working code, may not be optimized but it definitely compiles and does stuff. We will also go over some more principles that you are now ready to learn. There doesn’t seem to be anything on Swift code structure, nor an ANSI standard for it. This makes it the wild west equivalent for developers. No one likes that, especially when going between projects written by separate people.</p><p name="7ed0" id="7ed0" class="graf graf--p graf-after--p">So what’s next? Code Structure, Readability, and Principles.</p><p name="0238" id="0238" class="graf graf--p graf-after--p">After today, I shouldn’t have to tell you to practice, but I will. You should practice writing code every chance you get. When you aren’t doing that you should be reading articles on how this or that works. Maybe read something on <a href="https://stackoverflow.com/questions/24097826/read-and-write-a-string-from-text-file" data-href="https://stackoverflow.com/questions/24097826/read-and-write-a-string-from-text-file" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">how to write text to a file</a>, or how to build <a href="https://developer.apple.com/library/content/referencelibrary/GettingStarted/DevelopiOSAppsSwift/" data-href="https://developer.apple.com/library/content/referencelibrary/GettingStarted/DevelopiOSAppsSwift/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Apple’s Food Tracker app</a> which will get you acquainted with Xcode and making iOS Apps.</p><p name="ea61" id="ea61" class="graf graf--p graf-after--p">Tutorials about how to implement things go a long way, but it’s hard to break out of Tutorial-Mode because you run into the developer’s mindset. “You are never as good as you want to be.”</p><p name="4911" id="4911" class="graf graf--p graf-after--p">It is important for you to realize this early, especially since you are now fully capable of creating an App for someone else to use. It helps to think this way in the sense that it drives you to learn more constantly, however, in order to get better you need to try things on your own and refer back to the tutorials when you get stuck.</p><p name="14a4" id="14a4" class="graf graf--p graf-after--p">With that said… <strong class="markup--strong markup--p-strong">Keep Practicing!</strong></p><div name="9bc2" id="9bc2" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://medium.com/@broebling/beginning-swift-programming-part-10-code-structure-readability-and-principles-c84c30acd0cc" data-href="https://medium.com/@broebling/beginning-swift-programming-part-10-code-structure-readability-and-principles-c84c30acd0cc" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.com/@broebling/beginning-swift-programming-part-10-code-structure-readability-and-principles-c84c30acd0cc"><strong class="markup--strong markup--mixtapeEmbed-strong">Beginning Swift Programming Part 10 — Code Structure, Readability, and Principles</strong><br><em class="markup--em markup--mixtapeEmbed-em">In the last post, we covered basic protocols, extensions, and subscripting. Protocols have a lot more power, even more…</em>medium.com</a><a href="https://medium.com/@broebling/beginning-swift-programming-part-10-code-structure-readability-and-principles-c84c30acd0cc" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="f36c120abce69dc4c6d328a0d907aa2d" data-thumbnail-img-id="0*6TT5RBnuyHtUbt9y." style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*6TT5RBnuyHtUbt9y.);"></a></div><figure name="0cb1" id="0cb1" class="graf graf--figure graf-after--mixtapeEmbed graf--trailing"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 280px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 40%;"></div><a href="http://bit.ly/2KkkwGL" data-href="http://bit.ly/2KkkwGL" class="graf-imageAnchor" data-action="image-link" data-action-observe-only="true"rel="noopener"target="_blank"><img class="graf-image" data-image-id="1*5-oC2BqqizoRxIls08WMmA.png" data-width="1250" data-height="500" src="https://cdn-images-1.medium.com/max/800/1*5-oC2BqqizoRxIls08WMmA.png"></a></div></figure></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@broebling" class="p-author h-card">Bob Roebling</a> on <a href="https://medium.com/p/cdb0bb2ece71"><time class="dt-published" datetime="2018-04-11T04:31:01.314Z">April 11, 2018</time></a>.</p><p><a href="https://medium.com/@broebling/beginning-swift-programming-part-9-basic-protocols-extensions-and-subscripts-cdb0bb2ece71" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 1, 2019.</p></footer></article></body></html>