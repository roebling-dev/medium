<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Beginning Swift Programming Part 13 — Generics</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Beginning Swift Programming Part 13 — Generics</h1>
</header>
<section data-field="subtitle" class="p-summary">
Previously we covered type aliases, property observers, and Self vs self.
</section>
<section data-field="body" class="e-content">
<section name="46b9" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="0db5" id="0db5" class="graf graf--h3 graf--leading graf--title">Beginning Swift Programming Part 13 — Generics</h3><figure name="58fc" id="58fc" class="graf graf--figure graf-after--h3"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 525px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 74.9%;"></div><img class="graf-image" data-image-id="0*DJwOQHZXuXjWz2CJ." data-width="3652" data-height="2737" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*DJwOQHZXuXjWz2CJ."></div><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/@safesolvent?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com/@safesolvent?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-creator noopener noopener noopener" target="_blank">Martin Reisch</a> on <a href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-source noopener noopener noopener" target="_blank">Unsplash</a></figcaption></figure><p name="f2fa" id="f2fa" class="graf graf--p graf-after--figure">Previously we covered type aliases, property observers, and Self vs self.</p><div name="ba0b" id="ba0b" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://medium.com/@broebling/beginning-swift-programming-part-12-type-aliases-property-observers-and-self-versus-self-a8c02ce25b29" data-href="https://medium.com/@broebling/beginning-swift-programming-part-12-type-aliases-property-observers-and-self-versus-self-a8c02ce25b29" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.com/@broebling/beginning-swift-programming-part-12-type-aliases-property-observers-and-self-versus-self-a8c02ce25b29"><strong class="markup--strong markup--mixtapeEmbed-strong">Beginning Swift Programming Part 12 — Type Aliases, Property Observers, and Self versus self</strong><br><em class="markup--em markup--mixtapeEmbed-em">Previously we talked about Grand Central Dispatch and Closures.</em>medium.com</a><a href="https://medium.com/@broebling/beginning-swift-programming-part-12-type-aliases-property-observers-and-self-versus-self-a8c02ce25b29" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="e55dc254e6140cf89cc3c4febdc0e92a" data-thumbnail-img-id="0*ovxMMHqhF0O_pUiZ." style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*ovxMMHqhF0O_pUiZ.);"></a></div><p name="fef9" id="fef9" class="graf graf--p graf-after--mixtapeEmbed">About the time I tried talking about Self, I realized we were going to need to cover generics before Self could really be explained well.</p><p name="b506" id="b506" class="graf graf--p graf-after--p">It’s also a bit paradoxical because it’s difficult to explain generics without Self. Protocols can also use Self to really expand on their functionality. This being said, most articles go straight for generics or protocols and end up explaining all three all at once.</p><p name="eae7" id="eae7" class="graf graf--p graf-after--p">This makes it easier on the author who already understands the relationships, hard on the reader who is just learning one of the Swift features. This seems to be a common theme across technology, possibly in other fields. The easier it is on the developer or admin, the harder it is on the user and vice versa. The difficulty is constant but the burden of the task is split between each group. The best-written apps are usually the ones where the developer takes the difficult path.</p><h3 name="bea6" id="bea6" class="graf graf--h3 graf-after--p">Generics</h3><p name="464a" id="464a" class="graf graf--p graf-after--h3">While we have been writing code, have you ever thought “It sure would be nice if I didn’t have to type this same method to perform the same task for everything”? This is where generics come in.</p><p name="aa66" id="aa66" class="graf graf--p graf-after--p">Generics allow you to create reusable functions that can be used with different types as long as the type is compatible with the task being performed.</p><p name="8a9e" id="8a9e" class="graf graf--p graf-after--p">This means you could write a single function that could calculate tip amounts regardless of whether an int, double, or float was passed in to calculate the tip. It works for any Binary Integer type, but not so well with String types. Let’s take a look at our first generic function:</p><p name="9973" id="9973" class="graf graf--p graf-after--p">So we have some new syntax for you to look at. First is <code class="markup--code markup--p-code">&lt;T&gt;</code>. This could be anything inside of the brackets, most commonly we just use <code class="markup--code markup--p-code">T</code> to denote some <code class="markup--code markup--p-code">T</code>ype, you might also see this written as <code class="markup--code markup--p-code">&lt;Element&gt;</code>.</p><p name="cc9f" id="cc9f" class="graf graf--p graf-after--p">The next thing you might notice is the function declaration changed a little: <code class="markup--code markup--p-code">mutating func add&lt;T&gt;(newItem: T)</code>. This just reads as new <code class="markup--code markup--p-code">mutating func</code> called <code class="markup--code markup--p-code">add</code> which uses a generic type named <code class="markup--code markup--p-code">&lt;T&gt;</code> and takes a single argument <code class="markup--code markup--p-code">newItem</code> of type <code class="markup--code markup--p-code">T</code>. <code class="markup--code markup--p-code">mutating</code> means this function can alter, or mutate, the structures <code class="markup--code markup--p-code">items</code><em class="markup--em markup--p-em"> </em>array.</p><p name="8c8b" id="8c8b" class="graf graf--p graf-after--p">The type is inferred from whatever type the <code class="markup--code markup--p-code">List</code> was initially instantiated with. As soon as the compiler saw this line <code class="markup--code markup--p-code">var integerList = List&lt;Int&gt;()</code>, it changed all occurrences of <code class="markup--code markup--p-code">&lt;T&gt;</code> within the scope of the generic <code class="markup--code markup--p-code">List</code> structure to <code class="markup--code markup--p-code">&lt;Int&gt;</code>. Therefore the <code class="markup--code markup--p-code">items</code> array and all functions expected a type of <code class="markup--code markup--p-code">Int</code>.</p><p name="515f" id="515f" class="graf graf--p graf-after--p">If I created a new <code class="markup--code markup--p-code">List</code> using <code class="markup--code markup--p-code">&lt;String&gt;</code> and stored it in <code class="markup--code markup--p-code">stringList</code>, the array and functions would expect a type of <code class="markup--code markup--p-code">String</code> to be used.</p><p name="c870" id="c870" class="graf graf--p graf-after--p">You’ve probably seen this syntax before, like when we create dictionaries and arrays. We’ve been writing these shorthand, heavily relying on type inference, but behind the scenes Swift has come behind us and automatically expanded those types for us.</p><p name="7d48" id="7d48" class="graf graf--p graf-after--p">Integer arrays are declared using the syntax <code class="markup--code markup--p-code">[Int]()</code>, but swift expands this to <code class="markup--code markup--p-code">Array&lt;Int&gt;()</code></p><p name="70a6" id="70a6" class="graf graf--p graf-after--p">String dictionaries are declared using the syntax <code class="markup--code markup--p-code">[String: String]()</code>, but just like arrays Swift understand dictionaries as <code class="markup--code markup--p-code">Dictionary&lt;String: String&gt;()</code>.</p><p name="0b58" id="0b58" class="graf graf--p graf-after--p">With that syntax, we can determine that dictionaries and arrays are both generic types, they don’t care about what they are set to, they just care that any value that is used within them conforms to the type they are declared as.</p><p name="2fc1" id="2fc1" class="graf graf--p graf-after--p">So lets look at that second method. <code class="markup--code markup--p-code">func getItem&lt;T&gt;(at index: Int) -&gt; T?</code>. It works in the same way as <code class="markup--code markup--p-code">add</code>, swapping<code class="markup--code markup--p-code">T</code> to whatever type was used to create our <code class="markup--code markup--p-code">List</code>. But it uses <code class="markup--code markup--p-code">Int</code> as the parameter value. The reason for this, is becuase we need the integer-based index of the array. Even though the array’s contents are generic, the index is still an int.</p><p name="1bc4" id="1bc4" class="graf graf--p graf-after--p">Of course the element at that index will be our generic type, but what if the user hasn’t added anything to the array? We need to handle that situation just in case the element doesn’t exist. So we first check to make sure we have an item in our list. If we do, then we can try to get at that element. If we can’t get that element we just return <code class="markup--code markup--p-code">nil</code>.</p><p name="63e2" id="63e2" class="graf graf--p graf-after--p">Notice I said <em class="markup--em markup--p-em">try</em>. There is another issue with the logic and if you’ve been practicing you’ll know what it is. I’ll give you a hint. What if we add our three items to the array as we did above, but then perform the following statement:<br><code class="markup--code markup--p-code">let value = integerList.getItem(at: 3)</code>? Seems like we need to check for something else to keep our program from crashing. I’ll let you figure out how to do that.</p><p name="0d1e" id="0d1e" class="graf graf--p graf-after--p">Here’s another question for you. If we created a new list using <br><code class="markup--code markup--p-code">var doubleList = List&lt;Double&gt;()</code>, added the values 3, 4 , and 5 to our list, then used <code class="markup--code markup--p-code">let value = doubleList.getElement(at: 0)</code>. What is the <em class="markup--em markup--p-em">exact</em> text that would display in the console when you used <code class="markup--code markup--p-code">print(value)</code>?</p><figure name="8d42" id="8d42" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 467px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 66.7%;"></div><img class="graf-image" data-image-id="0*qIy8buflesfwjs7G." data-width="5184" data-height="3456" src="https://cdn-images-1.medium.com/max/800/0*qIy8buflesfwjs7G."></div><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/@katiemont1124?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com/@katiemont1124?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-creator noopener noopener noopener" target="_blank">Katie Montgomery</a> on <a href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-source noopener noopener noopener" target="_blank">Unsplash</a></figcaption></figure><h4 name="e7eb" id="e7eb" class="graf graf--h4 graf-after--figure">Conformance</h4><p name="6826" id="6826" class="graf graf--p graf-after--h4">You can have generics conform to specific protocols so they can only be instanciated with specific types. For example, when you use the protocol <code class="markup--code markup--p-code">BinaryInteger</code>, you are saying only signed (+/-) and unsigned (+) integers can use this generic method.</p><p name="7061" id="7061" class="graf graf--p graf-after--p">You can conform to any type but it’s best used with basic behaviors and base protocols such as <code class="markup--code markup--p-code">Numeric</code>, <code class="markup--code markup--p-code">Stridable</code>, <code class="markup--code markup--p-code">Sequence</code>, and/or <code class="markup--code markup--p-code">Collection</code>.</p><p name="0ffd" id="0ffd" class="graf graf--p graf-after--p">There are basic behaviors that you can conform to, a full list is found <a href="https://developer.apple.com/documentation/swift/basic_behaviors" data-href="https://developer.apple.com/documentation/swift/basic_behaviors" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">here</a>, but I will cover some of the most commonly used.</p><ul class="postList"><li name="2e15" id="2e15" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Equatable</strong> — ability to check if the value of one variable is equal to the value of another.</li><li name="1e45" id="1e45" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Comparable</strong> — ability to compare the value of one variable to another using relational (Boolean) operators. (e.g. greater than, less than, equal to)</li><li name="0d01" id="0d01" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Hashable</strong> — creates an integer hash value to allow you use the type in a set or as a dictionary key.</li></ul><p name="7af2" id="7af2" class="graf graf--p graf-after--li">Sometimes one will suffice for what you need, but other times, you may need to inherit from more than one.</p><p name="02f5" id="02f5" class="graf graf--p graf-after--p">For the best use of generics, you should look at the various protocols described in Apple’s documentation. Any protocol can be adopted, just make sure it makes sense with what you are trying to do. i.e. Don’t make a list of ages adopt the <code class="markup--code markup--p-code">FloatingPoint</code> protocol unless you are wanting to use the function with floating point (float, double) numbers.</p><p name="8b3b" id="8b3b" class="graf graf--p graf-after--p">Let’s take a look at how we can constrain a generic function to allow us to restrict what types can be used.</p><p name="c5d3" id="c5d3" class="graf graf--p graf-after--p">So by using the <code class="markup--code markup--p-code">Numeric</code> protocol, we tell the compiler, accept any type that is a number in replacement of <code class="markup--code markup--p-code">T</code>. This allows us to use the same function for multiple types.</p><p name="5d22" id="5d22" class="graf graf--p graf-after--p">It may not seem like much to be able to do something as simple as add two values together, but it does have power when you start doing more advanced techniques. The use of generics in a function format like this is one of those Swift features that isn’t utilized by new developers very much in their first projects. You can even write an entire app without creating generics, but one day you’ll come across a scenario where you will want to use the same function for two different data types. Now you just need to find the protocol that you would need to conform to and you can turn that strongly typed function into a generic function and re-use it as many times as you need in whichever type you need.</p><h4 name="27c6" id="27c6" class="graf graf--h4 graf-after--p">Generic in Protocols</h4><p name="9d43" id="9d43" class="graf graf--p graf-after--h4">This is that point in time where I was trying not to talk about generic protocols but wanted to talk about conformance and the examples I kept thinking of required generics in protocols.</p><p name="2820" id="2820" class="graf graf--p graf-after--p">Generics in protocols work as you’d expect them to, but conformance goes a long way with this. This also gives me a chance to talk about <code class="markup--code markup--p-code">Self</code> a little more as well as a close cousin of <code class="markup--code markup--p-code">typealias</code> called <code class="markup--code markup--p-code">associatedtype</code>.</p><p name="1298" id="1298" class="graf graf--p graf-after--p">First lets cover <code class="markup--code markup--p-code">Self</code>.</p><p name="c6c2" id="c6c2" class="graf graf--p graf-after--p">This is a binary search algorithm used in <a href="https://developer.apple.com/videos/play/wwdc2015/408/" data-href="https://developer.apple.com/videos/play/wwdc2015/408/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Apple’s WWDC 2015 video</a>, the way binary search works is much like you’d go through a dictionary or phone book. Let’s say you are looking for the word “Swift” in the dictionary.</p><ol class="postList"><li name="3fdc" id="3fdc" class="graf graf--li graf-after--p">First you open the book and you end up somewhere in the “M”s.</li><li name="f918" id="f918" class="graf graf--li graf--startsWithDoubleQuote graf-after--li">“S” is greater than “M” so you flip halfway to the back of the book and you end up somewhere in the “T”s.</li><li name="5563" id="5563" class="graf graf--li graf--startsWithDoubleQuote graf-after--li">“S” is less than “T” so you flip halfway back between “M” and “T”.</li><li name="10f8" id="10f8" class="graf graf--li graf-after--li">You keep doing this until you land on the page with “Swift”.</li></ol><p name="f116" id="f116" class="graf graf--p graf-after--li">In this example, we are providing a protocol that can be used with any type as long as the type is equatable to <code class="markup--code markup--p-code">Self</code>. <code class="markup--code markup--p-code">Self</code> in this context means we want to make sure the value that is passed in is also able to conform to the <code class="markup--code markup--p-code">Ordered</code> protocol. We have a number struct which is what we will use to compare a value of the same type.</p><p name="3f27" id="3f27" class="graf graf--p graf-after--p">In the binary search we pass in an array of anything that adopted the <code class="markup--code markup--p-code">Ordered</code> protocol, the key will be a single value that adopted the <code class="markup--code markup--p-code">Ordered</code> protocol.</p><p name="051f" id="051f" class="graf graf--p graf-after--p">We then get the high and low index of the array (since they are ordered), and proceed to find the value we are looking for. We first get the middle of the array. The algorithm <code class="markup--code markup--p-code">lo + (hi — lo) / 2</code> does this for us. 0 + (10 - 0) / 2 = 5. Later on if we go high 5 + (10–5) / 2 = 8 (rounded up because 5 / 2 = 2.5 which is rounded to 3).</p><p name="1d34" id="1d34" class="graf graf--p graf-after--p">Next we check <code class="markup--code markup--p-code">if sortedKeys[mid]</code> which is getting the value 5, <code class="markup--code markup--p-code">precedes(k)</code> or is before the value we are looking for, then we will set <code class="markup--code markup--p-code">lo = mid + 1</code> or one higher than the middle we just checked. If it’s not then we set <code class="markup--code markup--p-code">hi = mid</code> because we want to check everything lower than the <code class="markup--code markup--p-code">mid</code>.</p><p name="c6a2" id="c6a2" class="graf graf--p graf-after--p graf--trailing">And this will keep going until there is only one value left which becomes the <code class="markup--code markup--p-code">lo</code>.</p></div></div></section><section name="d091" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="6ef1" id="6ef1" class="graf graf--p graf--leading">Associated types are used as placeholders similar to <code class="markup--code markup--p-code">&lt;T&gt;</code> but are used in the protocol declaration, I’ll re-write the List example from above using a protocol with an associated type</p><p name="176f" id="176f" class="graf graf--p graf-after--p">First, we have our <code class="markup--code markup--p-code">associatedtype</code>, we will just call this <code class="markup--code markup--p-code">Item</code> because it makes sense to have <em class="markup--em markup--p-em">items</em> in an array.</p><p name="cc53" id="cc53" class="graf graf--p graf-after--p">Next we create our <code class="markup--code markup--p-code">items</code> array using a <em class="markup--em markup--p-em">getter</em> denoted by <code class="markup--code markup--p-code">{ get }</code>. This tells the compiler this should be read only. If we wanted it to be readable and writeable we could use <code class="markup--code markup--p-code">{ get set }</code>. In this case we only want the user to set the variable using the function <code class="markup--code markup--p-code">add</code>. I will talk more about getters and setters in a future article.</p><p name="40db" id="40db" class="graf graf--p graf-after--p">Again we have a <code class="markup--code markup--p-code">mutating func</code> because the function mutates itself, i.e. the struct that owns the method. And we create the method for getting items, nothing new here.</p><p name="d59d" id="d59d" class="graf graf--p graf-after--p">The <code class="markup--code markup--p-code">List&lt;T&gt;</code> struct, outside of the protocol adoption mostly stays the same as before. Of course, I didn’t create an extension for the protocol, which could have been done if we wanted to include default functionality, but sometimes when going between types, you might want different functionality. For example, with a <code class="markup--code markup--p-code">List&lt;String&gt;</code> do you want to append character arrays or string arrays? What about a <code class="markup--code markup--p-code">List&lt;Character&gt;</code>?</p><p name="77f3" id="77f3" class="graf graf--p graf-after--p graf--trailing">With our new knowledge that other protocols exist that common types such as <code class="markup--code markup--p-code">String</code>, <code class="markup--code markup--p-code">Int</code>, <code class="markup--code markup--p-code">Double</code>, etc… inherit from like <code class="markup--code markup--p-code">Numeric</code>, we could make an extension of <code class="markup--code markup--p-code">Numeric</code> that adopts the protocol and set up default functionality that would encompass all <code class="markup--code markup--p-code">Numeric</code> types. Then we could create one for <code class="markup--code markup--p-code">StringProtocol</code> types for Strings.</p></div></div></section><section name="62e4" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="8c3b" id="8c3b" class="graf graf--p graf--leading">There is one last thing I want to talk about with generics and that is the <code class="markup--code markup--p-code">where</code> clause. The where clause is an amendment to protocols or associatedtypes.</p><p name="5ac9" id="5ac9" class="graf graf--p graf-after--p">This states that <code class="markup--code markup--p-code">myProtocol</code> places a requirement on anything that adopts this protocol to also adopt <code class="markup--code markup--p-code">Hashable</code>. Typically conformance to Swift standard library protocols requires you to implement a few associated types, variables and/or methods that look a bit funky. In the case of hashable, you must add the following to your Struct or Class.</p><p name="ed29" id="ed29" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">hashvalue</code> is pretty straight-forward, but<code class="markup--code markup--p-code">static func ==(lhs:rhs:) -&gt; Bool</code> is all new for us.</p><p name="e474" id="e474" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">static</code> just means this can be called anywhere just by using <code class="markup--code markup--p-code">ListA == ListB</code> and compares the two Lists for equality. The <code class="markup--code markup--p-code">==</code> is where the equality comes from, it’s just adopting the operator in a way. <code class="markup--code markup--p-code">lhs</code> and <code class="markup--code markup--p-code">rhs</code> stand for left-hand side and right-hand side of the equality operator.</p><p name="0608" id="0608" class="graf graf--p graf-after--p">We are returning a Boolean but the implementation of the function is empty. So what goes in there? The logic you plan to use to check for equality. I just made a default implementation and it looks like this in context:</p><p name="4e13" id="4e13" class="graf graf--p graf-after--p">If <code class="markup--code markup--p-code">lhs</code> is equal to <code class="markup--code markup--p-code">rhs</code> we return true, otherwise false.</p><p name="06ae" id="06ae" class="graf graf--p graf-after--p">For the second part, the <code class="markup--code markup--p-code">where</code> clause with an associated type is when you want to provide functionality <em class="markup--em markup--p-em">if</em> the object that adopted the protocol also adopts the associated type’s requirement. If the object does, it get’s all methods that use the associated type, otherwise it doesn’t. The implementation might look something like this:</p><p name="9bda" id="9bda" class="graf graf--p graf-after--p">In short the difference of the where clause between the protocol level and the associated type level is this: When used at the protocol level, the adopting object is required to adopt the protocol referenced in the where clause. When used at the associated type level, the object is not required to adopt the protocol defined in the where clause but will not get access to all of the protocols available methods if it does not.</p><h3 name="23c2" id="23c2" class="graf graf--h3 graf-after--p">Summary</h3><p name="fff1" id="fff1" class="graf graf--p graf-after--h3">That about wraps up generics. They provide a lot of functionality with only a few changes to your code. It’s definitely something to keep in mind when you create your protocols. “Will this protocol be used for different types?”, “Are the types so different that I should look using the where clause to limit what functionality is provided?”</p><p name="23f5" id="23f5" class="graf graf--p graf-after--p">Hopefully I was able to teach you something about generics today. For more information you can take a look at Apple’s documentation on generics.</p><div name="354d" id="354d" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://docs.swift.org/swift-book/LanguageGuide/Generics.html#//apple_ref/doc/uid/TP40014097-CH26-ID179" data-href="https://docs.swift.org/swift-book/LanguageGuide/Generics.html#//apple_ref/doc/uid/TP40014097-CH26-ID179" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://docs.swift.org/swift-book/LanguageGuide/Generics.html#//apple_ref/doc/uid/TP40014097-CH26-ID179"><strong class="markup--strong markup--mixtapeEmbed-strong">Generics — The Swift Programming Language (Swift 4.2)</strong><br><em class="markup--em markup--mixtapeEmbed-em">Generic code enables you to write flexible, reusable functions and types that can work with any type, subject to…</em>docs.swift.org</a><a href="https://docs.swift.org/swift-book/LanguageGuide/Generics.html#//apple_ref/doc/uid/TP40014097-CH26-ID179" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="c1b679ba4f607175e252f3b49400be7e" data-thumbnail-img-id="0*_vfk7_GqZkjkIe-H" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*_vfk7_GqZkjkIe-H);"></a></div><h3 name="5128" id="5128" class="graf graf--h3 graf-after--mixtapeEmbed">What’s Next</h3><p name="9c40" id="9c40" class="graf graf--p graf-after--h3">The good news is the topics are almost over. This was a bit more difficult to write about because usually the cases where you’d use generics greatly differ. I think that this probably needs more discussion and I have a great use case for generics that can be used in many places, but before we talk about that, I need to cover one more topic.</p><p name="0bee" id="0bee" class="graf graf--p graf-after--p">Up next is Error Handling.</p><p name="cf81" id="cf81" class="graf graf--p graf-after--p">In programming, most people think about the driving logic behind how your app works to be the most important thing. While the logic is important, more important are things such as code comments, maintaining readabililty, consistency in file layouts and code structure, and finally how you handle errors in your code.</p><p name="f41e" id="f41e" class="graf graf--p graf-after--p">Anyone can make an app that does something neat, but how good is your app when the server API changes and you get data that you weren’t expecting? Your app will crash if you don’t handle the change properly. Because of the criticality of error handling, I’ll show you the iOS and macOS way of handling these errors because, yes, it is that important to notify your user when an error occurred.</p><p name="b6fa" id="b6fa" class="graf graf--p graf-after--p">Until then, practice writing your own generics, if you get stuck refer back to the documentation. Don’t stress if you don’t get it at first, generics take time.</p><div name="5a6e" id="5a6e" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://medium.com/@broebling/beginning-swift-programming-part-14-error-handling-919dea6771b0" data-href="https://medium.com/@broebling/beginning-swift-programming-part-14-error-handling-919dea6771b0" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.com/@broebling/beginning-swift-programming-part-14-error-handling-919dea6771b0"><strong class="markup--strong markup--mixtapeEmbed-strong">Beginning Swift Programming Part 14 — Error Handling</strong><br><em class="markup--em markup--mixtapeEmbed-em">In the previous article we talked about generics. It was hard info to go over, but that’s why we practice.</em>medium.com</a><a href="https://medium.com/@broebling/beginning-swift-programming-part-14-error-handling-919dea6771b0" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="eb5c793b82a6fc93d4b14a02d710e286" data-thumbnail-img-id="0*oTTfiAAesQT1iyOo." style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*oTTfiAAesQT1iyOo.);"></a></div><figure name="0cb1" id="0cb1" class="graf graf--figure graf-after--mixtapeEmbed graf--trailing"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 280px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 40%;"></div><a href="http://bit.ly/2KkkwGL" data-href="http://bit.ly/2KkkwGL" class="graf-imageAnchor" data-action="image-link" data-action-observe-only="true"rel="noopener"target="_blank"><img class="graf-image" data-image-id="1*5-oC2BqqizoRxIls08WMmA.png" data-width="1250" data-height="500" src="https://cdn-images-1.medium.com/max/800/1*5-oC2BqqizoRxIls08WMmA.png"></a></div></figure></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@broebling" class="p-author h-card">Bob Roebling</a> on <a href="https://medium.com/p/3cf65cb5292b"><time class="dt-published" datetime="2018-04-22T00:17:46.453Z">April 22, 2018</time></a>.</p><p><a href="https://medium.com/@broebling/beginning-swift-programming-part-13-generics-3cf65cb5292b" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 1, 2019.</p></footer></article></body></html>