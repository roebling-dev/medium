<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Beginning Swift Programming Part 2 — Value Types, Reference Types, Pointers, and Collection Types</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Beginning Swift Programming Part 2 — Value Types, Reference Types, Pointers, and Collection Types</h1>
</header>
<section data-field="subtitle" class="p-summary">
Previously we talked about variables, constants, and types.
</section>
<section data-field="body" class="e-content">
<section name="cc9a" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="7bb0" id="7bb0" class="graf graf--h3 graf--leading graf--title">Beginning Swift Programming Part 2 — Value Types, Reference Types, Pointers, and Collection Types</h3><figure name="d090" id="d090" class="graf graf--figure graf-after--h3"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 525px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 75%;"></div><img class="graf-image" data-image-id="0*ooUaN_QUInhRNVAu." data-width="4608" data-height="3456" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*ooUaN_QUInhRNVAu."></div><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/@designedbyjess?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com/@designedbyjess?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-creator noopener noopener noopener noopener noopener" target="_blank">Jess Watters</a> on <a href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-source noopener noopener noopener noopener noopener" target="_blank">Unsplash</a></figcaption></figure><p name="4df6" id="4df6" class="graf graf--p graf-after--figure">Previously we talked about variables, constants, and types.</p><div name="8e50" id="8e50" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://medium.com/swift2go/beginning-swift-programming-part-1-variables-constants-and-types-776ad50952f1" data-href="https://medium.com/swift2go/beginning-swift-programming-part-1-variables-constants-and-types-776ad50952f1" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.com/swift2go/beginning-swift-programming-part-1-variables-constants-and-types-776ad50952f1"><strong class="markup--strong markup--mixtapeEmbed-strong">Beginning Swift Programming Part 1 — Variables, Constants, and Types</strong><br><em class="markup--em markup--mixtapeEmbed-em">I know there are a lot of tutorials out there, Apple has good resources for learning Swift, including their WWDC videos…</em>medium.com</a><a href="https://medium.com/swift2go/beginning-swift-programming-part-1-variables-constants-and-types-776ad50952f1" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="aeedca8124f96f4533200236b9bc5b5c" data-thumbnail-img-id="0*uA6Wi6HVNT0QSluW." style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*uA6Wi6HVNT0QSluW.);"></a></div><p name="5401" id="5401" class="graf graf--p graf-after--mixtapeEmbed">In this part, we will talk about a couple of special types, but in order to do that in the depth I promised you, we must first talk about value types, reference types, and pointers.</p><p name="26f0" id="26f0" class="graf graf--p graf-after--p">Word of warning, pointers will probably be one of the hardest concepts to grasp, I will try my best.</p><h3 name="8bb4" id="8bb4" class="graf graf--h3 graf-after--p">Preliminary stuff</h3><p name="42c5" id="42c5" class="graf graf--p graf-after--h3">Yes, we did this last time and we will do it again now.<br>Last time we talked about memory and how it is arranged in blocks, bytes, and bits. I’d like to expand on that here and give you some visual representations of how memory works a little more.</p><p name="7eec" id="7eec" class="graf graf--p graf-after--p">Let’s create a string that holds the value <strong class="markup--strong markup--p-strong">Hello</strong>. Nothing special we’ve done this before.</p><p name="2f71" id="2f71" class="graf graf--p graf-after--p">I told you in the previous article that memory holds the value. If we could look at that memory it would be stored like this:</p><figure name="551a" id="551a" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 230px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 32.800000000000004%;"></div><img class="graf-image" data-image-id="1*H7xcy_Dx6KsCcSRGnQzj8A.png" data-width="1042" data-height="342" src="https://cdn-images-1.medium.com/max/800/1*H7xcy_Dx6KsCcSRGnQzj8A.png"></div></figure><p name="d29d" id="d29d" class="graf graf--p graf-after--figure">I bet you are asking what that <code class="markup--code markup--p-code">\0</code> is at the end of the string. That is referred to as a <em class="markup--em markup--p-em">null terminator.</em> The slash tells the program get ready for a command and the zero stands for nothing. This is how string values are stored and let the program know when the string is finished while still allowing spaces to be used.</p><p name="07ac" id="07ac" class="graf graf--p graf-after--p">Numbers are a little different.</p><figure name="be7f" id="be7f" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 230px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 32.800000000000004%;"></div><img class="graf-image" data-image-id="1*eaEHygl5FPyOe3Lfodb1GQ.png" data-width="1042" data-height="342" src="https://cdn-images-1.medium.com/max/800/1*eaEHygl5FPyOe3Lfodb1GQ.png"></div></figure><p name="0ea5" id="0ea5" class="graf graf--p graf-after--figure">Numbers are stored as binary numbers. Binary is easy to understand, start at 1 in the far right of the memory block, work your way left, multiplying the current value by 2 every time. If you know something about graphics cards or Memory sticks, it’s why we see 8-bit (Atari, NES), 16-bit (Sega Genesis, SNES), 32-bit (PlayStation), 64-bit (Nintendo 64), and so on.</p><p name="5c71" id="5c71" class="graf graf--p graf-after--p">In binary, if a position is 0, it is off, it’s false.<br>If a position is 1, it’s on, or true.<br>Based on this logic we only need to count the positions with a 1 in them. Can you figure out the number in the image above?</p><p name="9494" id="9494" class="graf graf--p graf-after--p">Now, this is a group of 8 bits of memory, that’s right, it is a full byte of memory. Previously I said each character in a string was 2 bytes, that means we used 16 bits to store a character. 16-bits in binary gives us the maximum value of 128. However, when we talk about positions, we always start with 0. So 16-bits gives you a full range of <code class="markup--code markup--p-code">0-127</code>. I bet you are asking how we can get characters out of that range. Well, in this case, I’ll point you to the <a href="http://www.asciitable.com" data-href="http://www.asciitable.com" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">ASCII table</a> where you can see the values for yourself. You’ll even see the hidden characters such as the null terminator <code class="markup--code markup--p-code">/0</code> as shown above. We refer to storing 8 bits per character as UTF-8, which is good for the English language, however, other languages require more bytes to display all of their characters and use UTF-16. UTF-32 also exists, but we use UTF-16 for performance reasons. If you are interested in digging deeper <a href="https://stackoverflow.com/a/643810" data-href="https://stackoverflow.com/a/643810" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">there is a great post on Stack Overflow</a> by <a href="https://medium.com/u/a5f9acb6e5c4" data-href="https://medium.com/u/a5f9acb6e5c4" data-anchor-type="2" data-user-id="a5f9acb6e5c4" data-action-value="a5f9acb6e5c4" data-action="show-user-card" data-action-type="hover" class="markup--user markup--p-user" target="_blank">Scott Tesler</a> that goes into detail on this.</p><figure name="ef91" id="ef91" class="graf graf--figure graf--layoutOutsetLeft graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 193px; max-height: 342px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 177.2%;"></div><img class="graf-image" data-image-id="1*ZWtMdrzlWjyEkrDUXMRWqA.png" data-width="193" data-height="342" src="https://cdn-images-1.medium.com/max/600/1*ZWtMdrzlWjyEkrDUXMRWqA.png"></div></figure><p name="3d3c" id="3d3c" class="graf graf--p graf-after--figure">Memory stores values in <em class="markup--em markup--p-em">static</em> memory, a place called the <em class="markup--em markup--p-em">stack</em>, and a place called the <em class="markup--em markup--p-em">heap.</em></p><p name="7dcd" id="7dcd" class="graf graf--p graf-after--p">Static memory and stack memory are quickly accessed, however accessing things from the heap is slow (in computer time). While it may not seem slow to you, what could take a millisecond or less to load from the stack, could take 10 ms to load from the heap. As I introduce things, I will explain where they are implemented so you know where you are putting things later on.</p><h3 name="8afa" id="8afa" class="graf graf--h3 graf-after--p">Value Types</h3><p name="f98c" id="f98c" class="graf graf--p graf-after--h3">Value types are simple to learn, it’s how we think about things naturally. When you describe something, let’s say a golf ball, you might say a golf ball is small, or a basketball is orange. Value types are pieces of memory that contain the value that you are looking for. If you stored the value <code class="markup--code markup--p-code">8</code> in memory and asked for the value later on, you’d receive the number 8, pretty simple right?</p><p name="0e8f" id="0e8f" class="graf graf--p graf-after--p">Strings, Integers, Doubles, Floats, and Bools are all value types, there are more, but we just haven’t covered them yet, all of my examples so far have been value types. Value types are stored in the stack. If you add static in front of them they are added to static memory, don’t just do this everywhere, it introduces another issue that I will talk about later.</p><figure name="da27" id="da27" class="graf graf--figure graf--startsWithDoubleQuote graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 467px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 66.7%;"></div><img class="graf-image" data-image-id="0*T-_hdDpulTYnPqa7." data-width="5016" data-height="3344" src="https://cdn-images-1.medium.com/max/800/0*T-_hdDpulTYnPqa7."></div><figcaption class="imageCaption">“Two “one-way” signs with arrows going different ways on a street in New York” by <a href="https://unsplash.com/@bdchu614?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com/@bdchu614?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-creator noopener noopener noopener noopener noopener" target="_blank">Brendan Church</a> on <a href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-source noopener noopener noopener noopener noopener" target="_blank">Unsplash</a></figcaption></figure><h3 name="b3d6" id="b3d6" class="graf graf--h3 graf-after--figure">Reference Types and Pointers</h3><p name="aeec" id="aeec" class="graf graf--p graf-after--h3">Reference types in a way are like value types in that they can give you the same values as value types, except they give you a whole lot more. Reference types use <em class="markup--em markup--p-em">pointers</em> to give you the value you are looking for.</p><p name="1d3a" id="1d3a" class="graf graf--p graf-after--p">That big long preliminary section was only made because this section warranted it.</p><p name="7ef5" id="7ef5" class="graf graf--p graf-after--p">If you look at C and Objective-C programs, you’ll see pointers used everywhere, it looks something like this</p><figure name="5e1a" id="5e1a" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/mildocjr/f122bede7e78f4b9caf123524201a8f2.js"></script></figure><p name="fb3e" id="fb3e" class="graf graf--p graf-after--figure">Using the example from C because it’s easier to understand, when I use <code class="markup--code markup--p-code">char *name = &quot;Bob&quot;</code> what happens is you make a pointer by using <code class="markup--code markup--p-code">*</code> this tells the system, give me an <em class="markup--em markup--p-em">address</em> where I can store this value in memory. The system then says ok you can use block 3 for your value. You then save <code class="markup--code markup--p-code">&quot;Bob&quot;</code> in block 3 (without quotes of course).</p><p name="061e" id="061e" class="graf graf--p graf-after--p">If you asked for the value of name using <code class="markup--code markup--p-code">printf(name);</code> you’d just see the address, which may look something like <code class="markup--code markup--p-code">0x03</code> only much longer. This is the <em class="markup--em markup--p-em">hexadecimal</em> representation of that block of memory. If you want the value <code class="markup--code markup--p-code">Bob</code> then you’d have to use <code class="markup--code markup--p-code">printf(*name);</code> (both print statements are in C).</p><p name="1fba" id="1fba" class="graf graf--p graf-after--p">In C if you wanted to change the value from anywhere, you would use <code class="markup--code markup--p-code">&amp;name</code> which says take the address of this value and do something with it. As the value changes, you can use it immediately with the new value by referencing <code class="markup--code markup--p-code">*name</code>. Pretty cool, yet very dangerous as you will later find out.</p><p name="f696" id="f696" class="graf graf--p graf-after--p">While Swift does rely heavily on value types, it does contain reference types. You will use both in every iPhone and Mac App whether you want to or not.</p><p name="5820" id="5820" class="graf graf--p graf-after--p">The reason why I bring up reference types is because of the more advanced types that we will talk about in the next part of this series, I just want you to think on how reference types work before we get started.</p><p name="1d66" id="1d66" class="graf graf--p graf-after--p">The way that I remember reference types is by imaging a treasure chest. It doesn’t belong to anyone, but as soon as I find it, I write down where it is so I can come back to it any time I want. If I want to look at the map at where it is or to tell someone else I use <code class="markup--code markup--p-code">&amp;</code>. If I want to open it and look at the treasure inside I use <code class="markup--code markup--p-code">*</code>. If I want to put something inside it, or take something out, I still have to use <code class="markup--code markup--p-code">*</code> to get to it first.</p><p name="7680" id="7680" class="graf graf--p graf-after--p">When you store a value such as <code class="markup--code markup--p-code">Bob</code> in a C pointer, you actually put each letter in a separate piece of memory. All you really know is where <code class="markup--code markup--p-code">B</code> is; the null terminator <code class="markup--code markup--p-code">/0</code> tells the computer when to stop <em class="markup--em markup--p-em">iterating</em> through pieces of memory and return whatever value it has. Think of it as a one button combo in Street Fighter. I’ll talk more about this when we get to collection types, if you make the connection as to how strings work in C (also called C-Strings) based on the type I will be presenting, then you are correct. Don’t go overboard and assume strings are a reference type in Swift, they are definitely value types.</p><p name="b67c" id="b67c" class="graf graf--p graf-after--p">As we continue, you’ll have some ideas. If you want to learn C, C++ or Objective-C this is all very important information, however, with Swift, they hide all of this complexity very well so you hardly ever have to worry about the <code class="markup--code markup--p-code">&amp;</code> or the <code class="markup--code markup--p-code">*</code> <em class="markup--em markup--p-em">operator</em>.</p><p name="2384" id="2384" class="graf graf--p graf-after--p">Reference types can be stored in the Stack, but they can also be stored on the heap. You’ll know if a reference type is stored on the heap if memory is manually allocated by the programmer for it using <code class="markup--code markup--p-code">malloc</code>.<br><em class="markup--em markup--p-em">Any variable created with malloc will not go away on its own when the program ends, you must call </em><code class="markup--code markup--p-code"><em class="markup--em markup--p-em">dealloc</em></code><em class="markup--em markup--p-em"> or </em><code class="markup--code markup--p-code"><em class="markup--em markup--p-em">free</em></code><em class="markup--em markup--p-em"> depending on your language in order to remove the value from memory, otherwise it will stay in memory until the computer is restarted. This is what is referred to as a “memory leak”.</em></p><figure name="0561" id="0561" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 547px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 78.10000000000001%;"></div><img class="graf-image" data-image-id="0*eGAAQpe12Bh_db0l." data-width="3496" data-height="2730" src="https://cdn-images-1.medium.com/max/800/0*eGAAQpe12Bh_db0l."></div><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/@erol?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com/@erol?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-creator noopener noopener noopener noopener noopener" target="_blank">Erol Ahmed</a> on <a href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-source noopener noopener noopener noopener noopener" target="_blank">Unsplash</a></figcaption></figure><h3 name="160c" id="160c" class="graf graf--h3 graf-after--figure">Collection Types</h3><p name="82c3" id="82c3" class="graf graf--p graf-after--h3">On to the final section of this part. Collection types are types that contain a collection of items. There are two main types: <em class="markup--em markup--p-em">arrays</em> and <em class="markup--em markup--p-em">dictionaries</em>.</p><ol class="postList"><li name="46c9" id="46c9" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Arrays</strong> — Arrays contain ordered like elements which are <em class="markup--em markup--li-em">addressable</em> by their index. The index is defined by the number of items from the beginning of the array. If we defined an array as such <br><code class="markup--code markup--li-code">var myArray = [&quot;eggs&quot;, &quot;milk&quot;, &quot;butter&quot;, &quot;cheese&quot;]</code> <br>we could get to each of those values using <code class="markup--code markup--li-code">‘myArray[0]’</code> which would give us the value <code class="markup--code markup--li-code">eggs</code> because it’s 0 places from the start of the array. Using this logic, if we wanted <code class="markup--code markup--li-code">butter</code> we would use <code class="markup--code markup--li-code">myArray[2]</code> because it is <code class="markup--code markup--li-code">2</code> places away from <code class="markup--code markup--li-code">eggs</code>.<br>If we wanted to change the value stored in an array we could use <br><code class="markup--code markup--li-code">var myArray[2] = &quot;Sugar&quot;<br></code>Arrays are defined with the type surrounded in brackets as in this example <code class="markup--code markup--li-code">var myIntegerArray = [Int]()<br></code>they can all so be declared with a type and instantiated without a value<br><code class="markup--code markup--li-code">var myDoubleArray: [Double] = []</code><br>In C-Strings this makes a little more sense suprisingly. When we stored <code class="markup--code markup--li-code">Bob</code> in a c-string, we actually made an array of characters (hence the char type). If we said <code class="markup--code markup--li-code">name[0]</code> it would just return <code class="markup--code markup--li-code">B</code> because it was 0 pieces of memory from the start of the array. You just need to be careful about staying within the bounds of the array, if you go outside of the array you will run into problems. Most of the time the computer will save you saying “index out of bounds” or something similar to that. If you run into this issue while your program is running, it will crash.</li><li name="9e37" id="9e37" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Dictionaries</strong> — I’ll give you one guess at why this is named the way it is. Dictionaries are similar to arrays in that they contain values of a common type, however, they are different as they are unordered. They do contain an index but the index is typically a string value. So with that knowledge you might be thinking of a word in the dictionary followed by its definition. That’s about how that works. you can define a dictionary using the following <br><code class="markup--code markup--li-code">var myDictionary = [&quot;Kevin&quot;: &quot;Lead Minion&quot;, &quot;Bob&quot;, &quot;Determined Minion&quot;, &quot;Stewart&quot;: &quot;Rocker Minion&quot;]</code> <br>we can get at the value of any one of these by using <code class="markup--code markup--li-code">myDictionary[&quot;Kevin&quot;]</code><br>you can set the value in a dictionary using the same syntax as an array just using the <em class="markup--em markup--li-em">key</em> to set the <em class="markup--em markup--li-em">value</em> as long as the value type can be used with the dictionary’s value type.<br><code class="markup--code markup--li-code">myDictionary[&quot;Bob&quot;] = &quot;King Bob&quot;</code> is allowed <br><code class="markup--code markup--li-code">myDictionary[&quot;Bob&quot;] = 2</code> is not allowed because the dictionary is of type <code class="markup--code markup--li-code">[String: String]</code>.<br>The <code class="markup--code markup--li-code">:</code> separates the key from the value. You can declare and instantiate dictionaries by using <br><code class="markup--code markup--li-code">var myStringDictionary = [String: String]()</code> <br>or <br><code class="markup--code markup--li-code">var myStringIntDictionary: [String: Int] = [:]</code> <br>both are valid.</li></ol><p name="6d83" id="6d83" class="graf graf--p graf-after--li">Dictionaries and Arrays are used extensively in Swift. You need to be careful with arrays to stay within the bounds of its elements. Dictionaries are a little more forgiving, and if you try to access a value that doesn’t exist in the dictionary, you get back nothing. Both dictionaries and arrays are stored in the stack (unless you are using malloc, then they are stored in the heap)</p><h3 name="9db8" id="9db8" class="graf graf--h3 graf-after--p">Summary</h3><p name="b46d" id="b46d" class="graf graf--p graf-after--h3">So today we learned about value types, reference types, collection types, a little bit more about memory.</p><h3 name="bb9a" id="bb9a" class="graf graf--h3 graf-after--p">What’s Next</h3><p name="e52b" id="e52b" class="graf graf--p graf-after--h3">In the next post, we will go over operators, optionals, and nil values. Most of the preliminary background information is over, and soon we will be having fun with programming.</p><div name="5c3a" id="5c3a" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://medium.com/swift2go/beginning-swift-programming-part-3-operators-optionals-and-nil-values-8454ae125b28" data-href="https://medium.com/swift2go/beginning-swift-programming-part-3-operators-optionals-and-nil-values-8454ae125b28" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.com/swift2go/beginning-swift-programming-part-3-operators-optionals-and-nil-values-8454ae125b28"><strong class="markup--strong markup--mixtapeEmbed-strong">Beginning Swift Programming Part 3 — Operators, Optionals, and Nil Values</strong><br><em class="markup--em markup--mixtapeEmbed-em">In the last post we covered value types, reference types, and finished with collection types. Today we are still going…</em>medium.com</a><a href="https://medium.com/swift2go/beginning-swift-programming-part-3-operators-optionals-and-nil-values-8454ae125b28" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="888f54b9a296a9a6b574a6b650954b5f" data-thumbnail-img-id="0*rzAyGBEjn8mVeS1C." style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*rzAyGBEjn8mVeS1C.);"></a></div><figure name="0cb1" id="0cb1" class="graf graf--figure graf-after--mixtapeEmbed graf--trailing"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 280px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 40%;"></div><a href="http://bit.ly/2KkkwGL" data-href="http://bit.ly/2KkkwGL" class="graf-imageAnchor" data-action="image-link" data-action-observe-only="true"rel="noopener"target="_blank"><img class="graf-image" data-image-id="1*5-oC2BqqizoRxIls08WMmA.png" data-width="1250" data-height="500" src="https://cdn-images-1.medium.com/max/800/1*5-oC2BqqizoRxIls08WMmA.png"></a></div></figure></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@broebling" class="p-author h-card">Bob Roebling</a> on <a href="https://medium.com/p/e48bc26a49bb"><time class="dt-published" datetime="2018-03-29T05:29:25.460Z">March 29, 2018</time></a>.</p><p><a href="https://medium.com/@broebling/beginning-swift-programming-part-2-value-types-reference-types-pointers-and-collection-types-e48bc26a49bb" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 1, 2019.</p></footer></article></body></html>