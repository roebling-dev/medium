<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Beginning Swift Programming Part 7 — Initialization and De-initialization, Overrides, and Reference…</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Beginning Swift Programming Part 7 — Initialization and De-initialization, Overrides, and Reference…</h1>
</header>
<section data-field="subtitle" class="p-summary">
In the previous post, we talked about structs, classes, properties, and methods.
</section>
<section data-field="body" class="e-content">
<section name="8932" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="a9ad" id="a9ad" class="graf graf--h3 graf--leading graf--title">Beginning Swift Programming Part 7 — Initialization and De-initialization, Overrides, and Reference Counting</h3><figure name="5148" id="5148" class="graf graf--figure graf-after--h3"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 467px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 66.7%;"></div><img class="graf-image" data-image-id="0*qSnluDYbmy54vmcm." data-width="6699" data-height="4471" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*qSnluDYbmy54vmcm."></div><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/@terrytandehao?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com/@terrytandehao?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-creator noopener noopener noopener" target="_blank">Terry Tan De Hao</a> on <a href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-source noopener noopener noopener" target="_blank">Unsplash</a></figcaption></figure><p name="81e5" id="81e5" class="graf graf--p graf-after--figure">In the previous post, we talked about structs, classes, properties, and methods.</p><div name="9e3e" id="9e3e" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://medium.com/swift2go/beginning-swift-programming-part-6-structs-classes-properties-and-methods-4c03af552e90" data-href="https://medium.com/swift2go/beginning-swift-programming-part-6-structs-classes-properties-and-methods-4c03af552e90" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.com/swift2go/beginning-swift-programming-part-6-structs-classes-properties-and-methods-4c03af552e90"><strong class="markup--strong markup--mixtapeEmbed-strong">Beginning Swift Programming Part 6 — Structs, Classes, Properties, and Methods</strong><br><em class="markup--em markup--mixtapeEmbed-em">In the last post we covered functions, enums, and scope.</em>medium.com</a><a href="https://medium.com/swift2go/beginning-swift-programming-part-6-structs-classes-properties-and-methods-4c03af552e90" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="0070510266ff0a5c1484a163e5e3788a" data-thumbnail-img-id="0*3PFQADarR0YnjQDP." style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*3PFQADarR0YnjQDP.);"></a></div><p name="1abd" id="1abd" class="graf graf--p graf-after--mixtapeEmbed">It helped us figure out how we could create objects and group like properties and methods together. The scope of this series will not teach you about the more specific classes Apple provides you, such as UIButton or the more hands-on URLSession. It will teach you enough so when you see these classes in your own programs, you’ll have an idea of how to start using them. So let’s dig into the lesson.</p><h3 name="e7e6" id="e7e6" class="graf graf--h3 graf-after--p">Initialization</h3><p name="bd48" id="bd48" class="graf graf--p graf-after--h3"><em class="markup--em markup--p-em">Initialization</em> for classes and structs, in the most basic sense, is providing classes and structs with a value. Sometimes we want a class or struct to have default values when it is created, other times we want to tell the class or struct what it’s default values are.</p><p name="e1ed" id="e1ed" class="graf graf--p graf-after--p">The difference between initializing a Class and initializing a Struct is this: Structs in Swift have their own <em class="markup--em markup--p-em">default initializer</em>, Classes do not. What does this mean? It means when we create a struct we do not need to have an <code class="markup--code markup--p-code">init()</code> method included in our Struct, it is created automatically for you. Classes must have an <code class="markup--code markup--p-code">init()</code> method, <em class="markup--em markup--p-em">only if a property of the class is not instantiated when the class is created</em>. Let’s see what I’m talking about.</p><p name="659e" id="659e" class="graf graf--p graf-after--p">In <code class="markup--code markup--p-code">myFullyInitializedClass</code> we can create it using <br><code class="markup--code markup--p-code">var myFirstClass = myFullyInitializedClass()</code>. If we were to call the function using <code class="markup--code markup--p-code">myFirstClass.myFunction()</code> it would return the integer<code class="markup--code markup--p-code">1</code> because we set an initial value for the class.</p><p name="457e" id="457e" class="graf graf--p graf-after--p">In <code class="markup--code markup--p-code">myNonInitializedClass</code>, we need to create it passing in a <code class="markup--code markup--p-code">givenNumber</code> so we initialize all properties of the class. In this case, we have only one property, but if we had more, we would have to pass in all of the default values. Just think of the <code class="markup--code markup--p-code">init()</code> method like a function without the <code class="markup--code markup--p-code">func</code> keyword for now. Its sole purpose is to assign values to properties within the class. When we call the method <code class="markup--code markup--p-code">myFunction</code> it will return the value <code class="markup--code markup--p-code">2</code>.</p><p name="a249" id="a249" class="graf graf--p graf-after--p">In the <code class="markup--code markup--p-code">myStruct</code> examples, we do not have an initializer because a default initializer is created for us behind the scenes. When we create a new struct we use <code class="markup--code markup--p-code">var myThirdStruct = myStruct(firstNumber: 3)</code>. No, we did not create 3 structs, but I named it this way so you could see the overall order of classes and structs. We can call <code class="markup--code markup--p-code">myThirdStruct.myFunction</code> and the method would return <code class="markup--code markup--p-code">3</code>.</p><p name="582a" id="582a" class="graf graf--p graf-after--p">If we were to create a new instance of <code class="markup--code markup--p-code">myStruct</code> and not pass in a default value for the first number, we’d get an error. So when it comes to structs you must either set a default value or pass one in when calling it.</p><p name="2172" id="2172" class="graf graf--p graf-after--p">Optionals can be used in classes and structs to satisfy the requirements for an initializer. Let’s say that you create a class that doesn’t always need all of its properties. We can set the properties we do not need immediately available to optional.</p><p name="fcd3" id="fcd3" class="graf graf--p graf-after--p">By using optional values, we did not have to include an initializer, however, as shown further down we need to force unwrap the optional to remove the <code class="markup--code markup--p-code">Optional(&lt;value&gt;)</code> wrapper around what our value was set to. I know that I told you to try not to use the <code class="markup--code markup--p-code">!</code> ,force unwrap, operator. But without more tools at your disposal, this will have to do for now. Don’t worry those new tools are coming up soon. If you do force unwrap a <code class="markup--code markup--p-code">nil</code> optional, your program will crash and you’ll get a nasty error saying<code class="markup--code markup--p-code">Found nil while unwrapping optional &lt;type&gt;</code>.</p><p name="74ab" id="74ab" class="graf graf--p graf-after--p">There are a few types of initializers, default initializers, which we just covered, required initializers, convenience initializers, and failable initializers.</p><p name="7f94" id="7f94" class="graf graf--p graf-after--p">Required initializers just mean that if you subclass from the class you are currently creating, the subclass must call the initializer from the parent, or superclass.</p><p name="485b" id="485b" class="graf graf--p graf-after--p">As shown above, by setting the initializer in <code class="markup--code markup--p-code">Vehicle</code> to <code class="markup--code markup--p-code">required</code>, we force <code class="markup--code markup--p-code">Car</code> to provide a fuelType to the superclass. We use <code class="markup--code markup--p-code">super.init</code> to access the superclass’s initializer. Don’t worry if this doesn’t make sense, I’ll re-write this in a minute to show how it works. By calling the <code class="markup--code markup--p-code">init</code> method of <code class="markup--code markup--p-code">Car</code>, we need to include the <code class="markup--code markup--p-code">fuelType</code> property from <code class="markup--code markup--p-code">Vehicle</code> so when we call <code class="markup--code markup--p-code">super.init</code> from within the <code class="markup--code markup--p-code">init</code> method, we can pass the <code class="markup--code markup--p-code">fuelType</code> value back to the <code class="markup--code markup--p-code">Vehicle</code> class. Let’s see how this works now.</p><p name="cf04" id="cf04" class="graf graf--p graf-after--p">So it’s really the same as if the <code class="markup--code markup--p-code">Vehicle</code> class was never there. “Why don’t we just use it this way instead?” The answer is simple, extensibility. Going off our first example of subclassing let’s extend this out.</p><p name="f418" id="f418" class="graf graf--p graf-after--p">In this example, we provide a <code class="markup--code markup--p-code">Truck</code> class which has it’s own property <code class="markup--code markup--p-code">bedSize</code>. Then we create a <code class="markup--code markup--p-code">SemiTruck</code> class, which also has an initializer but only takes in <code class="markup--code markup--p-code">hasSleeper</code>. We set the <code class="markup--code markup--p-code">fuelType</code> to <code class="markup--code markup--p-code">.diesel</code> because for this example, all Semi-trucks run on diesel fuel. This is allowed.</p><p name="3d1f" id="3d1f" class="graf graf--p graf-after--p">That brings us to convenience initializers. Convenience initializers work in the same way as that last example but are used to set default values when you don’t care to set the values yourself.</p><p name="5911" id="5911" class="graf graf--p graf-after--p">This allows us to just call <code class="markup--code markup--p-code">Person()</code> without setting a value and we get a default <code class="markup--code markup--p-code">name</code> of <code class="markup--code markup--p-code">&quot;unknown person&quot;</code>. These can be a helpful alternative to using optionals throughout a class.</p><p name="b59f" id="b59f" class="graf graf--p graf-after--p">Failable initializers can protect you from setting a class’s property to the wrong value and allow you to return nil if the class could not be initialized.</p><p name="e3b1" id="e3b1" class="graf graf--p graf-after--p">Here we set up the failable initializer using <code class="markup--code markup--p-code">init?</code>, this allows us to cancel out of initialization returning nil to the variable. <em class="markup--em markup--p-em">Using failable initializers also makes the variable that holds the class optional.</em> Here if we do not pass in a name, we return nil, otherwise, we return an optional <code class="markup--code markup--p-code">myFailableClass</code> instance.</p><figure name="a2d0" id="a2d0" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 465px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 66.4%;"></div><img class="graf-image" data-image-id="0*VLLRNseTFqeFrGgn." data-width="4288" data-height="2848" src="https://cdn-images-1.medium.com/max/800/0*VLLRNseTFqeFrGgn."></div><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/@hoiko24?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com/@hoiko24?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-creator noopener noopener noopener" target="_blank">Heejing KIM</a> on <a href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-source noopener noopener noopener" target="_blank">Unsplash</a></figcaption></figure><h3 name="c137" id="c137" class="graf graf--h3 graf-after--figure">De-initialization</h3><p name="37f5" id="37f5" class="graf graf--p graf-after--h3"><em class="markup--em markup--p-em">De-initialization</em> is simply cleaning up any loose ends when you are done with a class. Soon we will talk about reference counting, but anytime you create a class you create a <em class="markup--em markup--p-em">reference</em> to it, if you have another object that uses this class, we use de-initialization to help the other object “forget” this class. For this example, I’m going to talk about the Swift <code class="markup--code markup--p-code">Timer</code> class. Timers create a <em class="markup--em markup--p-em">strong reference</em> to the class they are used in. When we are done with our class, we want to remove the timer from our class, let’s see how that’s done.</p><p name="bcdd" id="bcdd" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">deinit</code> is called right before the class we are in is removed from memory. When we use <code class="markup--code markup--p-code">myCounter = nil</code> the class prepares to remove itself from memory. It calls <code class="markup--code markup--p-code">deinit</code> and runs whatever code is in there, whether that is to copy data out to save it somewhere, or in our case, check if the timer is still valid and if it is, invalidate it.</p><p name="0372" id="0372" class="graf graf--p graf-after--p">Invalidating a timer tells the timer to release it’s reference to the class that <em class="markup--em markup--p-em">owns</em> it and perform any other cleanup tasks that are necessary for it to remove itself from memory. Once the timer is destroyed, the owning class then finishes the<code class="markup--code markup--p-code">deinit</code> and removes itself from memory.</p><figure name="b524" id="b524" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 467px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 66.7%;"></div><img class="graf-image" data-image-id="0*O1zw5HZvJJRAzsQR." data-width="6000" data-height="4000" src="https://cdn-images-1.medium.com/max/800/0*O1zw5HZvJJRAzsQR."></div><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/@chrislawton?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com/@chrislawton?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-creator noopener noopener noopener" target="_blank">Chris Lawton</a> on <a href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-source noopener noopener noopener" target="_blank">Unsplash</a></figcaption></figure><h3 name="12bc" id="12bc" class="graf graf--h3 graf-after--figure">Overrides</h3><p name="22a8" id="22a8" class="graf graf--p graf-after--h3">Overrides allow you to subclass and change the default initializer of the superclass.</p><p name="2c01" id="2c01" class="graf graf--p graf-after--p">Here we have a superclass of <code class="markup--code markup--p-code">Ball</code>, it comes with a default initializer of <code class="markup--code markup--p-code">init()</code>, because we are calling an initializer from <code class="markup--code markup--p-code">Basketball</code> with the same name, we use the <code class="markup--code markup--p-code">override</code> keyword. We’d still need to call <code class="markup--code markup--p-code">super.init</code> so the superclass can do its work, but we’d end up setting the default value of <code class="markup--code markup--p-code">3</code> for the <code class="markup--code markup--p-code">Basketball</code> class.</p><p name="cec7" id="cec7" class="graf graf--p graf-after--p">We also use the <code class="markup--code markup--p-code">override</code> keyword on methods that have the same name and exist in a parent class. Here we override the method <code class="markup--code markup--p-code">bouceHeight</code> because it has the same <em class="markup--em markup--p-em">method signature</em> as the parent class. The method signature is just another way of saying it looks exactly the same and should be called in the same way. The only difference is that instead of returning <br><code class="markup--code markup--p-code">Double(size) * 0.5</code> we return <code class="markup--code markup--p-code">Double(size) * 0.75</code>. The process of converting from one type to another is called <em class="markup--em markup--p-em">casting</em>. We will talk about that in the next part of this series.</p><p name="a9f0" id="a9f0" class="graf graf--p graf-after--p">Don’t worry too much about when you need to override, Xcode generates a nice error message when you need to use the override keyword and even autocompletes it for you when you click on the error.</p><h3 name="e52c" id="e52c" class="graf graf--h3 graf-after--p">Reference Counting</h3><p name="1eb8" id="1eb8" class="graf graf--p graf-after--h3">Whenever you create a class in Swift, you create a reference to an object. When this reference is created the system creates a counter along with it. This counter directly refers to the number of objects (including variables) that point to it.</p><figure name="910d" id="910d" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 654px; max-height: 608px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 93%;"></div><img class="graf-image" data-image-id="1*l4nAAdPwlS8Pfh8l29wcVg.png" data-width="654" data-height="608" src="https://cdn-images-1.medium.com/max/800/1*l4nAAdPwlS8Pfh8l29wcVg.png"></div></figure><p name="cdc8" id="cdc8" class="graf graf--p graf-after--figure">Here we have two references, both A and B point to Data, and so we update the counter to say there are two references. If A were to be set to <code class="markup--code markup--p-code">nil</code> then we’d only have one reference to Data.</p><p name="41a6" id="41a6" class="graf graf--p graf-after--p">What happens if both A and B no longer reference Data? According to the laws of memory, Data would sit there indefinitely. Either until the computer was turned off (clearing the memory) or by a coincidence, we happened to access the entire block of memory that contained data and either set it to <code class="markup--code markup--p-code">nil</code> or, more likely, wrote new values over the top of what data used to be.</p><p name="47a1" id="47a1" class="graf graf--p graf-after--p">Thanks to operating systems, we don’t have to panic about this situation too much. In Swift, more accurately the <em class="markup--em markup--p-em">clang compiler</em>, we have a feature called ARC (Automatic Reference Counting) that comes through at various times, checks memory for any data that no longer has references to it, and deallocates it from memory. This used to be called garbage collection back in the old Objective-C days, and garbage collection is still used by many languages. It doesn’t mean one is better or worse than the other, it’s just a different process for how data gets released from memory.</p><p name="c86e" id="c86e" class="graf graf--p graf-after--p">Where ARC gets hung up is when we have <em class="markup--em markup--p-em">strong references</em> hanging around. Using the counter class above, let’s illustrate how this looks.</p><figure name="9d84" id="9d84" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 354px; max-height: 348px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 98.3%;"></div><img class="graf-image" data-image-id="1*4hzvhbKu6yYfRyVKgv49_Q.png" data-width="354" data-height="348" src="https://cdn-images-1.medium.com/max/800/1*4hzvhbKu6yYfRyVKgv49_Q.png"></div></figure><p name="c321" id="c321" class="graf graf--p graf-after--figure">Because Counter owns Timer, and Timer creates a reference back to Counter, each of them both have a reference count of 1. If we deallocate Counter without removing this strong reference, Timer exists on its own with a reference count of 1 until the computer is turned off. ARC can’t handle this situation. This is what is referred to as a <em class="markup--em markup--p-em">memory leak. </em>Which is simply a way to say that an object is sitting on its own in memory and will never go away.</p><p name="f6b1" id="f6b1" class="graf graf--p graf-after--p">Memory leaks of any size aren’t good and we should all strive to not have any, but as you first start off, it will happen. It doesn’t mean you will run out of memory immediately, it just means while you have that leaky memory, you will not be able to use that memory for anything else. Turning your computer off for about 15 seconds is the easiest way to fix it. “Ahh, that’s why the cable company tells me to turn my router off for 15 seconds.” Exactly, if you have corrupt memory, turning the device off clears the corrupted memory and it functions normally after re-writing the correct data back to memory.</p><p name="cda2" id="cda2" class="graf graf--p graf-after--p">So if we deallocate Timer, we still have control over deallocating the class, and all is good when we do.</p><p name="5693" id="5693" class="graf graf--p graf-after--p">Another way you can help with strong reference cycles like this is to mark classes that will cause a strong reference with the <code class="markup--code markup--p-code">weak</code> or <code class="markup--code markup--p-code">unowned</code> keyword.</p><p name="3d17" id="3d17" class="graf graf--p graf-after--p"><a href="https://medium.com/u/d7a9f5548202" data-href="https://medium.com/u/d7a9f5548202" data-anchor-type="2" data-user-id="d7a9f5548202" data-action-value="d7a9f5548202" data-action="show-user-card" data-action-type="hover" class="markup--user markup--p-user" target="_blank">Ilea Cristian</a> put it best in <a href="https://stackoverflow.com/questions/24011575/what-is-the-difference-between-a-weak-reference-and-an-unowned-reference" data-href="https://stackoverflow.com/questions/24011575/what-is-the-difference-between-a-weak-reference-and-an-unowned-reference" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">his answer on Stack Overflow</a>:</p><blockquote name="e226" id="e226" class="graf graf--blockquote graf-after--p">A <code class="markup--code markup--blockquote-code"><em class="markup--em markup--blockquote-em">weak</em></code> reference allows the posibility of it to become <code class="markup--code markup--blockquote-code"><em class="markup--em markup--blockquote-em">nil</em></code> (this happens automatically when the referenced object is deallocated), therefore the type of your property must be optional - so you, as a programmer, are obligated to check it before you use it (basically the compiler forces you, as much as it can, to write safe code).</blockquote><blockquote name="8a8d" id="8a8d" class="graf graf--blockquote graf-after--blockquote">An <code class="markup--code markup--blockquote-code"><em class="markup--em markup--blockquote-em">unowned</em></code> reference presumes that it will never become <code class="markup--code markup--blockquote-code"><em class="markup--em markup--blockquote-em">nil</em></code> during it&#39;s lifetime. A unowned reference must be set during initialization - this means that the reference will be defined as a non-optional type that can be used safely without checks. If somehow the object being referred is deallocated, then the app will crash when the unowned reference will be used.</blockquote><p name="4c00" id="4c00" class="graf graf--p graf-after--blockquote">That is what helped me to finally understand the concept of <code class="markup--code markup--p-code">unowned</code> vs <code class="markup--code markup--p-code">weak</code>.</p><h3 name="f073" id="f073" class="graf graf--h3 graf-after--p">Summary</h3><p name="e86c" id="e86c" class="graf graf--p graf-after--h3">We learned about Initialization, how to do it, and why it&#39;s so important with classes. Most of the time in Swift you will be writing structs, every once in a while you’ll need to use a class. The rule of thumb is to start with a struct, move to a class if you run into limitations.</p><p name="f98b" id="f98b" class="graf graf--p graf-after--p">Then we learned about deinitialization and when it is necessary. It’s not required to include it in every class, but make sure to use it when you might end up with a strong reference cycle.</p><p name="a1f9" id="a1f9" class="graf graf--p graf-after--p">We learned a little about overrides and why you need them and finished up with one of the most important topics that you need to be conscious of when you write your programs with reference types: Reference counting. Knowing that you could end up with a memory leak and preventing it, is something you have direct control over when it comes to bugs in your app. It won’t cause your app to crash but it can be just as bad or worse by making the user’s computer crash from lack of memory.</p><p name="4296" id="4296" class="graf graf--p graf-after--p">Suggested reading:</p><ul class="postList"><li name="eecc" id="eecc" class="graf graf--li graf-after--p">Read through Functions, Enumerations, Classes and Structures, Properties, Methods, Inheritance, Initialization, Deinitialization, and Automatic Reference Counting in the Swift Programming Language.</li></ul><div name="d3eb" id="d3eb" class="graf graf--mixtapeEmbed graf-after--li"><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Functions.html" data-href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Functions.html" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Functions.html"><strong class="markup--strong markup--mixtapeEmbed-strong">Functions — The Swift Programming Language (Swift 4.2)</strong><br><em class="markup--em markup--mixtapeEmbed-em">Functions are self-contained chunks of code that perform a specific task. You give a function a name that identifies…</em>developer.apple.com</a><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Functions.html" class="js-mixtapeImage mixtapeImage mixtapeImage--empty u-ignoreBlock" data-media-id="15c2046b17ac85df5d37056040c763a9"></a></div><p name="0513" id="0513" class="graf graf--p graf-after--mixtapeEmbed">I know it sounds like it is a lot of information, but with the primer I have given you since the last bit of reading, you should be able to go through it pretty quickly and get more in-depth information on topics you might be struggling with.</p><h3 name="024e" id="024e" class="graf graf--h3 graf-after--p">What’s Next</h3><p name="6b6e" id="6b6e" class="graf graf--p graf-after--h3">Up next is Type Casting, Safely Unwrapping Optionals, and Access Control. It should be pretty quick to go through and it will provide a lot of power in terms of flexibility to your toolset.</p><p name="6d28" id="6d28" class="graf graf--p graf-after--p">As always, keep practicing your new skills, we’re more than halfway through.</p><div name="1cf6" id="1cf6" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://medium.com/@broebling/beginning-swift-programming-part-8-type-casting-safely-unwrapping-optionals-and-access-control-179c28b19a5e" data-href="https://medium.com/@broebling/beginning-swift-programming-part-8-type-casting-safely-unwrapping-optionals-and-access-control-179c28b19a5e" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.com/@broebling/beginning-swift-programming-part-8-type-casting-safely-unwrapping-optionals-and-access-control-179c28b19a5e"><strong class="markup--strong markup--mixtapeEmbed-strong">Beginning Swift Programming Part 8 — Type Casting, Safely Unwrapping Optionals, and Access Control</strong><br><em class="markup--em markup--mixtapeEmbed-em">In the last post, we talked about initialization, deinitialization, overrides, and reference counting. In this part we…</em>medium.com</a><a href="https://medium.com/@broebling/beginning-swift-programming-part-8-type-casting-safely-unwrapping-optionals-and-access-control-179c28b19a5e" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="f98afff84bdd827d5b03bef8342cef4b" data-thumbnail-img-id="0*8e51xdxq7O9M0vH2." style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*8e51xdxq7O9M0vH2.);"></a></div><figure name="0cb1" id="0cb1" class="graf graf--figure graf-after--mixtapeEmbed graf--trailing"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 280px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 40%;"></div><a href="http://bit.ly/2KkkwGL" data-href="http://bit.ly/2KkkwGL" class="graf-imageAnchor" data-action="image-link" data-action-observe-only="true"rel="noopener"target="_blank"><img class="graf-image" data-image-id="1*5-oC2BqqizoRxIls08WMmA.png" data-width="1250" data-height="500" src="https://cdn-images-1.medium.com/max/800/1*5-oC2BqqizoRxIls08WMmA.png"></a></div></figure></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@broebling" class="p-author h-card">Bob Roebling</a> on <a href="https://medium.com/p/4e745ba40d0c"><time class="dt-published" datetime="2018-04-07T05:47:08.604Z">April 7, 2018</time></a>.</p><p><a href="https://medium.com/@broebling/beginning-swift-programming-part-7-initialization-and-de-initialization-overrides-and-reference-4e745ba40d0c" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 1, 2019.</p></footer></article></body></html>