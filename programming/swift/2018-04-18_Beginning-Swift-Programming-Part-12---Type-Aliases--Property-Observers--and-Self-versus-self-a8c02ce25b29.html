<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Beginning Swift Programming Part 12 — Type Aliases, Property Observers, and Self versus self</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Beginning Swift Programming Part 12 — Type Aliases, Property Observers, and Self versus self</h1>
</header>
<section data-field="subtitle" class="p-summary">
Previously we talked about Grand Central Dispatch and Closures.
</section>
<section data-field="body" class="e-content">
<section name="b0f8" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="a456" id="a456" class="graf graf--h3 graf--leading graf--title">Beginning Swift Programming Part 12 — Type Aliases, Property Observers, and Self versus self</h3><figure name="51c4" id="51c4" class="graf graf--figure graf-after--h3"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 410px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 58.599999999999994%;"></div><img class="graf-image" data-image-id="0*tvku9AD7g4KIvJNf." data-width="5957" data-height="3493" src="https://cdn-images-1.medium.com/max/800/0*tvku9AD7g4KIvJNf."></div><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/@alfonsmc10?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com/@alfonsmc10?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-creator noopener" target="_blank">Alfons Morales</a> on <a href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-source noopener" target="_blank">Unsplash</a></figcaption></figure><p name="2e8e" id="2e8e" class="graf graf--p graf-after--figure">Previously we talked about Grand Central Dispatch and Closures.</p><div name="55c0" id="55c0" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://medium.com/@broebling/beginning-swift-programming-part-11-grand-central-dispatch-and-closures-293132b6a69d" data-href="https://medium.com/@broebling/beginning-swift-programming-part-11-grand-central-dispatch-and-closures-293132b6a69d" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.com/@broebling/beginning-swift-programming-part-11-grand-central-dispatch-and-closures-293132b6a69d"><strong class="markup--strong markup--mixtapeEmbed-strong">Beginning Swift Programming Part 11 — Grand Central Dispatch and Closures</strong><br><em class="markup--em markup--mixtapeEmbed-em">Previously we learned about code structure, readability, and a few more principles.</em>medium.com</a><a href="https://medium.com/@broebling/beginning-swift-programming-part-11-grand-central-dispatch-and-closures-293132b6a69d" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="321067d5b73a495ed887a75a9fa3e4ed" data-thumbnail-img-id="0*nCTzBn2gK4pAK-Mn." style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*nCTzBn2gK4pAK-Mn.);"></a></div><p name="5a40" id="5a40" class="graf graf--p graf-after--mixtapeEmbed">It was a tough one but you’ll be happy to know that all of the hard stuff is behind us. This article will introduce new concepts to help you make your code more readable, slim your code down, and give you some context in the realm of <code class="markup--code markup--p-code">Self</code> vs <code class="markup--code markup--p-code">self</code>, other than that capital <code class="markup--code markup--p-code">S</code>.</p><h3 name="b0b2" id="b0b2" class="graf graf--h3 graf-after--p">Type Aliases</h3><p name="68b6" id="68b6" class="graf graf--p graf-after--h3">Type Aliases help make our code more readable and our lives as a developer a little more bearable. You might understand this to be called as <code class="markup--code markup--p-code">alias</code> or <code class="markup--code markup--p-code">typedef</code> in other languages but in Swift we use <code class="markup--code markup--p-code">typealias</code>.</p><p name="8c30" id="8c30" class="graf graf--p graf-after--p">A typealias is simply renaming a type to something easier to use or understand. In your code, you might use <code class="markup--code markup--p-code">typealias</code> to take a raw type and rename it to something that works better for your context. Let’s look at an example:</p><figure name="cec9" id="cec9" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/mildocjr/8d608eafc6fbfb673f098141d6bba192.js"></script></figure><p name="8cba" id="8cba" class="graf graf--p graf-after--figure">It’s not too hard to read this, it’s pretty easy to follow along with what is going on here, but at first glance, you might wonder about <code class="markup--code markup--p-code">pageContents</code> and why it’s type is <code class="markup--code markup--p-code">[Int:String]</code> why wouldn’t it just be a <code class="markup--code markup--p-code">String</code> since we are referring to its page content only? Well, books have multiple pages, and we need to figure out what page we are on right? That’s why we make <code class="markup--code markup--p-code">pageContents</code> a dictionary of type <code class="markup--code markup--p-code">[Int: String]</code>.</p><p name="ecfb" id="ecfb" class="graf graf--p graf-after--p">But what’s more important is that we had to think about why we might use <code class="markup--code markup--p-code">[Int: String]</code> after we had already come to that conclusion, or maybe we are new to the project and this is what we see. This is where typealiases come in handy. Let’s re-write this using a couple of type aliases.</p><figure name="6e3d" id="6e3d" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/mildocjr/978831a99b01b521bf2795dfb495ae74.js"></script></figure><p name="4efb" id="4efb" class="graf graf--p graf-after--figure">Here I’ve replaced all standard types with a type alias that makes more sense for this context. In the background, it’s exactly the same as it is above, but from our perspective, it’s all in context.</p><p name="cd48" id="cd48" class="graf graf--p graf-after--p">Something to know about type aliases is that, just like variables, they are governed by scope. If you define a type alias in a class or struct, you cannot use it outside of that class or struct. You’ll get an error stating Xcode has no idea what <em class="markup--em markup--p-em">typealiasName</em> is.</p><p name="7e31" id="7e31" class="graf graf--p graf-after--p">So I’ll give you another example using something a little more technical and I’ll start off by describing something called JSON (JavaScript Object Notation). Don’t worry I&#39;m not teaching you Javascript, just a brief primer on JSON.</p><p name="e24d" id="e24d" class="graf graf--p graf-after--p">JSON is used primarily in web services to pass data back and forth between clients and servers, it also serves a purpose to store data on a local device that is easy to parse and easy to maintain. JSON typically looks like this</p><figure name="c922" id="c922" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/mildocjr/4eec0bd13ca5edfa687e09fb8fc469dc.js"></script></figure><p name="7326" id="7326" class="graf graf--p graf-after--figure">The way this would translate to Swift is:</p><figure name="429a" id="429a" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/mildocjr/ed2df5e7711fbf90674a573f9f135d81.js"></script></figure><p name="b052" id="b052" class="graf graf--p graf-after--figure">(Hint: I just replaced the curly braces with square brackets)</p><p name="d658" id="d658" class="graf graf--p graf-after--p">But we can refer to this as <code class="markup--code markup--p-code">[String: Any]</code>, and cast each level to whatever object we need it as. So let’s look at the example now.</p><figure name="2300" id="2300" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/mildocjr/9513b09688e99d35fc81434b8b8acd27.js"></script></figure><p name="bf4c" id="bf4c" class="graf graf--p graf-after--figure">The JSON itself for this example might look something like this</p><figure name="3977" id="3977" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/mildocjr/b0b1520091b0950453aacd4c321ad782.js"></script></figure><p name="d772" id="d772" class="graf graf--p graf-after--figure">Now going back to the example, we could refactor this so we wouldn’t have to type <code class="markup--code markup--p-code">[String: Any]</code> so much.</p><figure name="cacd" id="cacd" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/mildocjr/17dd71d0ded333444b77e2ee21319979.js"></script></figure><p name="b701" id="b701" class="graf graf--p graf-after--figure">See how much more sense this makes? While we are trying to parse the JSON we, ourselves, can infer the type based on what the type alias is. If I tell you I’m going to give you jsonData, you just expect it to be <code class="markup--code markup--p-code">[String: Any]</code> or at least something that starts with a string and can contain multiple types. When we want a character from the book, we should expect to be receiving a <code class="markup--code markup--p-code">String</code>. If I tell you I’m going to give you a list, you should expect an array of something, in this case, I’m giving you a list of sidekicks, so you should expect an array of strings <code class="markup--code markup--p-code">[String]</code>.</p><p name="8b27" id="8b27" class="graf graf--p graf-after--p">Type aliases are nice, they definitely help with readability, but they can be overdone. I might have overdone it that in the last example but normally I just use it for dictionaries like <code class="markup--code markup--p-code">[String: Any]</code> or closure types like <br><code class="markup--code markup--p-code">typealias completion = () -&gt; ()</code>, where later you can pass in <code class="markup--code markup--p-code">completion</code> to a closure function instead of <code class="markup--code markup--p-code">() -&gt; ()</code> every time you use it.</p><figure name="8649" id="8649" class="graf graf--figure graf--startsWithDoubleQuote graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 467px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 66.7%;"></div><img class="graf-image" data-image-id="0*ovxMMHqhF0O_pUiZ." data-width="6000" data-height="4000" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*ovxMMHqhF0O_pUiZ."></div><figcaption class="imageCaption">“A figurine of a stormtrooper under a desk lamp with an incandescent light bulb” by <a href="https://unsplash.com/@shotbyjamespond?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com/@shotbyjamespond?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-creator noopener" target="_blank">James Pond</a> on <a href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-source noopener" target="_blank">Unsplash</a></figcaption></figure><h3 name="3f78" id="3f78" class="graf graf--h3 graf-after--figure">Property Observers</h3><p name="51b5" id="51b5" class="graf graf--p graf-after--h3">On to the next thing, property observers are nice because they help you automate some stuff that needs to happen every time a variable gets updated.</p><p name="ddff" id="ddff" class="graf graf--p graf-after--p">Property Observers basically observe a property for changes. They come in two forms.</p><ul class="postList"><li name="446b" id="446b" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">willSet</code> — performs actions before the variable is set</li><li name="8c8e" id="8c8e" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">didSet</code> — performs actions after the variable is set</li></ul><p name="2000" id="2000" class="graf graf--p graf-after--li">I hardly ever use <code class="markup--code markup--p-code">willSet</code>, but I use <code class="markup--code markup--p-code">didSet</code> all the time.</p><p name="f6c4" id="f6c4" class="graf graf--p graf-after--p">Property observers fit in your code like this:</p><figure name="635d" id="635d" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/mildocjr/054ee5f3c4caffe6404943d5c18dcb0d.js"></script></figure><p name="facc" id="facc" class="graf graf--p graf-after--figure">Ok, that’s great right, but what’s the use case. Well, I named our class <code class="markup--code markup--p-code">StockMarket</code> because it would make sense for us to use both. I’m also going to rely on assumptions that the methods exist somewhere below because that’s not what’s important here.</p><figure name="0d35" id="0d35" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/mildocjr/6e87ae40f12fa63074c06b535dd68a2b.js"></script></figure><p name="156f" id="156f" class="graf graf--p graf-after--figure">I know this seems tricky but I’ll walk you through it. First, we have a few type aliases just because I wanted to keep it going with an example of where <br><code class="markup--code markup--p-code">[String: Int]</code> means nothing, but <code class="markup--code markup--p-code">[name: amount]</code> gives clarity to what it is used for.</p><p name="6c22" id="6c22" class="graf graf--p graf-after--p">Then where we actually use the property observers, the <code class="markup--code markup--p-code">wallet</code>. Initially, we set the value to $100. Sorry for my international readers, I’m a bit rusty on Euros, Dinar, Florin, and Yen. Then we get to <code class="markup--code markup--p-code">willSet</code>.</p><p name="3c14" id="3c14" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">willSet</code> provides us a variable for free called <code class="markup--code markup--p-code">newValue</code>. It’s the value what we are setting <code class="markup--code markup--p-code">wallet</code> to. Here we use it to <code class="markup--code markup--p-code">updateBuyingPower</code>, like any good storefront we ask for the money first then give you the goods.</p><p name="0904" id="0904" class="graf graf--p graf-after--p">Next, we hit the <code class="markup--code markup--p-code">didSet</code> property observer. Just like <code class="markup--code markup--p-code">willSet</code> we get a variable for free called <code class="markup--code markup--p-code">oldValue</code>. This is the value what <code class="markup--code markup--p-code">wallet</code> was before we set it. It’s kind of nice to know if something goes wrong in <code class="markup--code markup--p-code">getStock</code>in our property observer we can set <code class="markup--code markup--p-code">wallet</code> back to its previous value. Here it’s a perfect world.</p><p name="676c" id="676c" class="graf graf--p graf-after--p">Finally, I use something called <em class="markup--em markup--p-em">string interpolation</em> which allows us to use a string with variables embedded inside of it. You can use string interpolation in a string by using <code class="markup--code markup--p-code">\()</code> and placing your code inside. It’s a shorthand way of using <code class="markup--code markup--p-code">firstName + &quot; &quot; + lastName</code>. Instead, we can just use <br><code class="markup--code markup--p-code">&quot;\(firstName) \(lastName)&quot;</code>. While it seems cumbersome in that example, it doesn’t seem so bad in my example above. In that example, we even do a little arithmetic on the old wallet value and the current wallet value to figure out the difference and report it back to the user.</p><p name="9a9a" id="9a9a" class="graf graf--p graf-after--p">So here’s a challenge for you, the code I wrote above (which I thought about fixing), has an error in it.</p><p name="8be8" id="8be8" class="graf graf--p graf-after--p">Our users can only purchase stock, they will never get their money back. See if you can come up with a way (using your own method names if needed) of allowing them to sell their stock.</p><p name="cb7d" id="cb7d" class="graf graf--p graf-after--p">Bonus, earlier I mentioned that you could revert back to a previous value. Except if we were to do so as it is, we’d end up in an infinite loop. See if you can roll back to the previous value if something fails in the purchase process without creating an infinite loop.</p><p name="5965" id="5965" class="graf graf--p graf-after--p">There’s no harm in creating an infinite loop in Swift while you have the ability to stop the program, so playgrounds are the best place to try this out.</p><p name="6781" id="6781" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Warning</strong>: the longer you let the infinite loop go the longer it may take to stop because the computer has to catch up to the instruction where you clicked stop.</p><p name="ad93" id="ad93" class="graf graf--p graf-after--p">If you need a hint, I wrote a <a href="https://medium.com/@broebling/beginning-swift-programming-part-4-decision-making-and-loops-9b87b309d69e" data-href="https://medium.com/@broebling/beginning-swift-programming-part-4-decision-making-and-loops-9b87b309d69e" class="markup--anchor markup--p-anchor" target="_blank">well-received article</a> that might help point you in the right direction.</p><p name="144a" id="144a" class="graf graf--p graf-after--p">Property observers don’t have to be used with both <code class="markup--code markup--p-code">willSet</code> and <code class="markup--code markup--p-code">didSet</code>, if you only need one, you only have to write one. See this example of how you might implement a score label in a game.</p><figure name="7375" id="7375" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/mildocjr/0e8ff934b5cfe0b955c0080da2b007b8.js"></script></figure><figure name="099b" id="099b" class="graf graf--figure graf-after--figure"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 467px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 66.7%;"></div><img class="graf-image" data-image-id="0*rqrn2nCiw62wAxXC." data-width="3000" data-height="2000" src="https://cdn-images-1.medium.com/max/800/0*rqrn2nCiw62wAxXC."></div><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/@allentaylorjr?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com/@allentaylorjr?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-creator noopener" target="_blank">Allen Taylor</a> on <a href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-source noopener" target="_blank">Unsplash</a></figcaption></figure><h3 name="5d9e" id="5d9e" class="graf graf--h3 graf-after--figure">Self vs self</h3><p name="bc32" id="bc32" class="graf graf--p graf-after--h3">Yes, there is a difference! The difference is huge, even though it looks subtle.</p><p name="a3f8" id="a3f8" class="graf graf--p graf-after--p">In classes and structs, sometimes we have to refer to a property of that entity, from within a method owned by that entity. In cases where you do this, you must use the lowercase <code class="markup--code markup--p-code">self</code>. Let’s take a look at an example</p><figure name="5868" id="5868" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/mildocjr/bd3170f92b9f12b5f49274639088b080.js"></script></figure><p name="0f86" id="0f86" class="graf graf--p graf-after--figure">But it’s not really required here. We could easily drop off <code class="markup--code markup--p-code">self</code> in this example and it would still work. However…</p><figure name="3a6c" id="3a6c" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/mildocjr/520fb20228d3608fcf430bf99e5be710.js"></script></figure><p name="21f8" id="21f8" class="graf graf--p graf-after--figure">When we have to create an initializer, the normal syntax is to use the same name as what the property name is. It helps to have this context when you create a new <code class="markup--code markup--p-code">Kid</code> class in your code. But while you are looking at the initialization code it wouldn’t make much sense if you wrote it like this:</p><p name="80b1" id="80b1" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">hasPillow = hasPillow</code></p><p name="5ca4" id="5ca4" class="graf graf--p graf-after--p">It just looks like we are assigning itself to itself. This is called ambiguity. Ambiguity occurs when you have something that could mean one or more things without more context. By adding <code class="markup--code markup--p-code">self</code>, we satisfy this ambiguity.</p><p name="5b86" id="5b86" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">self.hasPillow = hasPillow</code></p><p name="3bac" id="3bac" class="graf graf--p graf-after--p">OH, I see now, we want to assign the <code class="markup--code markup--p-code">hasPillow</code> variable that was passed in during initialization to the <code class="markup--code markup--p-code">hasPillow</code> property of our <code class="markup--code markup--p-code">self</code>. <code class="markup--code markup--p-code">self</code> in this case, refers to <em class="markup--em markup--p-em">this instance of the class</em>. Not all the kids get a pillow… but this kid does.</p><p name="feaf" id="feaf" class="graf graf--p graf-after--p">Other times when you are working with View Controllers you may want to show a different view. In this case, we use:</p><figure name="a5ea" id="a5ea" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/mildocjr/4b9d5ddd2ee277fcdfc93cfcb2eff11c.js"></script></figure><p name="6960" id="6960" class="graf graf--p graf-after--figure">Here we are saying whatever view controller is currently active if you have a <code class="markup--code markup--p-code">navigationController</code> (noted by the optional <code class="markup--code markup--p-code">?</code>) <code class="markup--code markup--p-code">present</code> this <code class="markup--code markup--p-code">newViewController</code> and let&#39;s make it <code class="markup--code markup--p-code">animated</code> (<code class="markup--code markup--p-code">: true</code>), and on <code class="markup--code markup--p-code">completion:</code> of the present method, do nothing <code class="markup--code markup--p-code">nil</code>.</p><p name="9200" id="9200" class="graf graf--p graf-after--p">So using <code class="markup--code markup--p-code">self</code> can get you out of typing <code class="markup--code markup--p-code">AReallyLongViewControllerName</code>. Even with autocompletion, let’s face it, <code class="markup--code markup--p-code">self</code> is so much cleaner looking.</p><p name="604f" id="604f" class="graf graf--p graf-after--p">On to <code class="markup--code markup--p-code">self</code>&#39;s not so alike twin: <code class="markup--code markup--p-code">Self</code>.</p><p name="26c8" id="26c8" class="graf graf--p graf-after--p">Similar to how<code class="markup--code markup--p-code">self</code> refers to the class you are in, <code class="markup--code markup--p-code">Self</code> makes a reference but to the type of object that we want to refer to. <code class="markup--code markup--p-code">Self</code> is used in three ways, since I’ve only taught you about one of those, I’ll explain it using protocols.</p><p name="5820" id="5820" class="graf graf--p graf-after--p">Yay protocols, maybe nay protocols for some, but they really are powerful and this might change your mind about them.</p><p name="368c" id="368c" class="graf graf--p graf-after--p">Protocols allow you to define functionality that can be used with anything that adopts the protocol but more importantly they can be flexible in their implementation.</p><p name="1e4a" id="1e4a" class="graf graf--p graf-after--p">So if we used this protocol extension:</p><figure name="fc62" id="fc62" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/mildocjr/f52de5f7e294fa117559d117bcabfc07.js"></script></figure><p name="aad3" id="aad3" class="graf graf--p graf-after--figure"><code class="markup--code markup--p-code"><em class="markup--em markup--p-em">BinaryInteger</em></code><em class="markup--em markup--p-em"> is a protocol provided in Swift.</em></p><p name="77f7" id="77f7" class="graf graf--p graf-after--p">Here we make an extension with the function <code class="markup--code markup--p-code">doubled() -&gt; Self</code>. We don’t care what <code class="markup--code markup--p-code">Self</code> is, we just know that whatever our function does should be compatible with BinaryInteger types. Later we could use this:</p><figure name="da25" id="da25" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/mildocjr/ad60dca07338c1a3c87f895792fe739d.js"></script></figure><p name="1df1" id="1df1" class="graf graf--p graf-after--figure">What’s interesting about this is that we could also do this:</p><figure name="6cb2" id="6cb2" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/mildocjr/cbb9564a415df60dfe9491ed2b94960a.js"></script></figure><p name="564d" id="564d" class="graf graf--p graf-after--figure">Do you know why?</p><p name="aa2c" id="aa2c" class="graf graf--p graf-after--p">Well the default type for any integer type without a <code class="markup--code markup--p-code">.0</code> behind it, or <code class="markup--code markup--p-code">1...9</code> for that matter, is an <code class="markup--code markup--p-code">Int</code>. <code class="markup--code markup--p-code">Int</code> conforms to the <code class="markup--code markup--p-code">BinaryInteger</code> protocol and by relation, our extension containing the <code class="markup--code markup--p-code">doubled()</code> function.</p><p name="f788" id="f788" class="graf graf--p graf-after--p">All of this was made possible by the <code class="markup--code markup--p-code">Self</code> keyword. Yes we could use other <code class="markup--code markup--p-code">Int</code> types such as <code class="markup--code markup--p-code">Int8</code>, <code class="markup--code markup--p-code">Int32</code>, <code class="markup--code markup--p-code">UInt64</code>, and so on, they are all <code class="markup--code markup--p-code">BinaryIntegers</code>, and they all adopt this new function. When you call the function the type is inferred and everywhere we used <code class="markup--code markup--p-code">Self</code> is replaced by the type that we are using to call this function. <code class="markup--code markup--p-code">self</code> is replaced by the value we passed in.</p><p name="9c6d" id="9c6d" class="graf graf--p graf-after--p">Don’t worry if this doesn’t make sense, I plan to talk about Generics shortly and all of this will make a little more sense.</p><h3 name="30d2" id="30d2" class="graf graf--h3 graf-after--p">Summary</h3><p name="c8dd" id="c8dd" class="graf graf--p graf-after--h3">So today was pretty easy and laid back, we talked about type aliases and how they can make your code more readable. We discussed property observers and how they can handle performing some tasks for you. Finally, we covered <code class="markup--code markup--p-code">Self</code> vs <code class="markup--code markup--p-code">self</code>. There was a little more info on <code class="markup--code markup--p-code">self</code>. But do not get discouraged because <code class="markup--code markup--p-code">Self</code> will be more important as we progress into generics.</p><h3 name="252f" id="252f" class="graf graf--h3 graf-after--p">What’s Next</h3><p name="7319" id="7319" class="graf graf--p graf-after--h3">So I’m debating, I could go the easy route and talk about error handling, which is very important and very easy to do, or I could talk about generics which is very new to you, and more difficult, not as bad as closures though!</p><p name="5482" id="5482" class="graf graf--p graf-after--p">…time passes by…</p><p name="bb1c" id="bb1c" class="graf graf--p graf-after--p">OK, although I’d like to be nice and easy to let closures sink in a little more, I think I’m still going to drag you down the path of generics. It’s some really cool stuff and works with protocols, extensions, enums…. let’s face it, you can use generics in a lot of places.</p><p name="f1e1" id="f1e1" class="graf graf--p graf-after--p">So what’s next? Generics is up next.</p><p name="bf80" id="bf80" class="graf graf--p graf-after--p">Due to the number of places you can use generics, and not really having thought too deeply about the amount of content that I might have to write to explain the various use cases while keeping the article under 15 minutes, I’m going to err on the side of caution and Make it a one-topic article. I’ll do my best to explain it as my part of the bargain for your learning experience but in order for any of this to click you need to keep up your end. In case you forgot what your end is:</p><p name="70b4" id="70b4" class="graf graf--p graf-after--p">Keep practicing!</p><div name="cfa7" id="cfa7" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://medium.com/@broebling/beginning-swift-programming-part-13-generics-3cf65cb5292b" data-href="https://medium.com/@broebling/beginning-swift-programming-part-13-generics-3cf65cb5292b" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.com/@broebling/beginning-swift-programming-part-13-generics-3cf65cb5292b"><strong class="markup--strong markup--mixtapeEmbed-strong">Beginning Swift Programming Part 13 — Generics</strong><br><em class="markup--em markup--mixtapeEmbed-em">Previously we covered type aliases, property observers, and Self vs self. About the time I tried talking about Self, I…</em>medium.com</a><a href="https://medium.com/@broebling/beginning-swift-programming-part-13-generics-3cf65cb5292b" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="dbb76900769f8f0e74546e1bf3e65636" data-thumbnail-img-id="0*DJwOQHZXuXjWz2CJ." style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*DJwOQHZXuXjWz2CJ.);"></a></div><figure name="0cb1" id="0cb1" class="graf graf--figure graf-after--mixtapeEmbed graf--trailing"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 280px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 40%;"></div><a href="http://bit.ly/2KkkwGL" data-href="http://bit.ly/2KkkwGL" class="graf-imageAnchor" data-action="image-link" data-action-observe-only="true"rel="noopener"target="_blank"><img class="graf-image" data-image-id="1*5-oC2BqqizoRxIls08WMmA.png" data-width="1250" data-height="500" src="https://cdn-images-1.medium.com/max/800/1*5-oC2BqqizoRxIls08WMmA.png"></a></div></figure></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@broebling" class="p-author h-card">Bob Roebling</a> on <a href="https://medium.com/p/a8c02ce25b29"><time class="dt-published" datetime="2018-04-18T04:45:54.205Z">April 18, 2018</time></a>.</p><p><a href="https://medium.com/@broebling/beginning-swift-programming-part-12-type-aliases-property-observers-and-self-versus-self-a8c02ce25b29" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 1, 2019.</p></footer></article></body></html>