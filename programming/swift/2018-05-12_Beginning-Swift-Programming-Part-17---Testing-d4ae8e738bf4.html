<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Beginning Swift Programming Part 17 — Testing</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Beginning Swift Programming Part 17 — Testing</h1>
</header>
<section data-field="subtitle" class="p-summary">
In the previous article, we talked about inout, lazy, and getters and setters.
</section>
<section data-field="body" class="e-content">
<section name="5538" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="f8ed" id="f8ed" class="graf graf--h3 graf--leading graf--title">Beginning Swift Programming Part 17 — Testing</h3><figure name="ccbe" id="ccbe" class="graf graf--figure graf-after--h3"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 467px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 66.7%;"></div><img class="graf-image" data-image-id="0*34QPxRkx_CVqg2XL." data-width="5472" data-height="3648" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*34QPxRkx_CVqg2XL."></div><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/@freestocks?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com/@freestocks?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-creator noopener" target="_blank">freestocks.org</a> on <a href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-source noopener" target="_blank">Unsplash</a></figcaption></figure><p name="ec5f" id="ec5f" class="graf graf--p graf-after--figure">In the previous article, we talked about <code class="markup--code markup--p-code">inout</code>, lazy, and getters and setters.</p><div name="6fd0" id="6fd0" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://medium.com/@broebling/beginning-swift-programming-part-16-inout-lazy-and-getters-and-setters-99fe68cf8b54" data-href="https://medium.com/@broebling/beginning-swift-programming-part-16-inout-lazy-and-getters-and-setters-99fe68cf8b54" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.com/@broebling/beginning-swift-programming-part-16-inout-lazy-and-getters-and-setters-99fe68cf8b54"><strong class="markup--strong markup--mixtapeEmbed-strong">Beginning Swift Programming Part 16 — inout, Lazy, and Getters and Setters</strong><br><em class="markup--em markup--mixtapeEmbed-em">Previously we covered using Generics and Closures with Enums.</em>medium.com</a><a href="https://medium.com/@broebling/beginning-swift-programming-part-16-inout-lazy-and-getters-and-setters-99fe68cf8b54" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="c2e3fbc228ee9ad7319ba64b6f64fb2a" data-thumbnail-img-id="0*p7C4tOLuVi2sBtGs." style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*p7C4tOLuVi2sBtGs.);"></a></div><p name="448b" id="448b" class="graf graf--p graf-after--mixtapeEmbed">In this article, we are focusing on writing tests. You might think this is optional because it doesn’t perform any logic that will ship with your app. If you think that way, you <em class="markup--em markup--p-em">will</em> fail your job interview.</p><h3 name="ac98" id="ac98" class="graf graf--h3 graf-after--p">Testing</h3><p name="8d61" id="8d61" class="graf graf--p graf-after--h3">Testing is important and a term comes to mind whenever I hear it. <em class="markup--em markup--p-em">Test-driven Development (TDD)</em>. Test-driven development is a popular way to write applications and the formula is easy to remember.</p><ol class="postList"><li name="d43f" id="d43f" class="graf graf--li graf-after--p">Write a failing test case.</li><li name="f81b" id="f81b" class="graf graf--li graf-after--li">Write enough code and no more for the test to pass.</li><li name="2b4c" id="2b4c" class="graf graf--li graf-after--li">Test to ensure the case passes.</li></ol><p name="ab2a" id="ab2a" class="graf graf--p graf-after--li">There are other ways to test. You can use simple print statements to show the before and after results of a piece of code which is an OK way to test. You can also run your app to ensure nothing is breaking which is the bare minimum way to test that you’d probably do anyway.</p><p name="348b" id="348b" class="graf graf--p graf-after--p">I will only be covering TDD in this article. Before we get started, I’d like to bring up two new terms. <em class="markup--em markup--p-em">Test Ratio</em> and <em class="markup--em markup--p-em">Code Coverage</em>.</p><ul class="postList"><li name="e5e2" id="e5e2" class="graf graf--li graf-after--p">Test Ratio — The ratio is lines of code to the number of tests written. Many people will say 1 line of code should be tested with 3 tests written as 1:3.</li><li name="7897" id="7897" class="graf graf--li graf-after--li">Code Coverage — involves how much of your code has been tested as a percentage. Many IDEs will offer a code coverage view that highlights code based on test status. Green means there is a test for it, red means there is not.</li></ul><p name="747b" id="747b" class="graf graf--p graf-after--li">While I should default to “test everything” like everyone else, I won’t. You do not need to go to the extremes of testing functions included with Swift or other libraries that have included tests. I would not write a test case for a print statement or some other static method such as <code class="markup--code markup--p-code">Date.init()</code>. You really only need to test your code with the exception of someone else’s code that does not include tests.</p><p name="bb40" id="bb40" class="graf graf--p graf-after--p">How we write tests look about like this:</p><figure name="f678" id="f678" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/mildocjr/f177548ba651e3af721b30a1dbca32f3.js"></script></figure><p name="ed57" id="ed57" class="graf graf--p graf-after--figure">Let’s go over this line by line. <code class="markup--code markup--p-code">import XCTest</code> imports the library provided by Apple for testing. <code class="markup--code markup--p-code">@testable import ViewController</code> <code class="markup--code markup--p-code">@testable</code> is an attribute that elevates the access scope for the module. It essentially changes the access level from <code class="markup--code markup--p-code">internal</code> or <code class="markup--code markup--p-code">private</code> to <code class="markup--code markup--p-code">open</code> but only for your local tests. <code class="markup--code markup--p-code">import ViewController</code> is the import statement that includes the Class you wish to test.</p><p name="9533" id="9533" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">class ViewControllerTests: XCTestCase { ... }</code> defines a class that inherits all of the functionality from <code class="markup--code markup--p-code">XCTestCase</code>. If you are using any properties whether this is another class, or perhaps some constants or variables that will be used often in your test cases replace <code class="markup--code markup--p-code">// Testing properties here</code> with those properties.</p><p name="ba6d" id="ba6d" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">override func setUp()</code>. Think of this as the <code class="markup--code markup--p-code">viewDidLoad()</code> for your test cases. When you start testing this is called to create classes or to instantiate variables.</p><p name="ca07" id="ca07" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">override func tearDown()</code>. This is the equivalent of <code class="markup--code markup--p-code">deinit {}</code> in your View Controllers. Remove anything that might cause a memory leak here, <code class="markup--code markup--p-code">Timer</code> is a good example of what should be removed.</p><p name="958d" id="958d" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">func test_multiplyByTwoReturnsFour()</code>. This is one of many naming conventions but it provides intent on what this test is used for. Always start your test cases with <code class="markup--code markup--p-code">test</code> The <code class="markup--code markup--p-code">_</code> is optional but helps with readability. Then <code class="markup--code markup--p-code">multiplyByTwo</code> is what we are doing, <code class="markup--code markup--p-code">ReturnsFour</code> is what we are expecting. If you write your cases this way, you will always know what each test case is used for and what the expected results are. What if we only return odd numbers and round up at the end? We might write a test case like <br><code class="markup--code markup--p-code">func test_getOddFromMultiplyByTwo_ReturnsFive()</code>.</p><p name="608a" id="608a" class="graf graf--p graf-after--p">Finally, we have <code class="markup--code markup--p-code">XCTAssertEqual(value, value)</code>. This is an actual test case that checks if both values are equal. <code class="markup--code markup--p-code">XCTAssert</code> is a common prefix, so if you start typing <code class="markup--code markup--p-code">XCT</code> autocompletion in XCode will give you a plethora of methods that you can use. In this case, if both values are equal, the test passes, if not it fails.</p><p name="474b" id="474b" class="graf graf--p graf-after--p">Some other common tests are <code class="markup--code markup--p-code">XCTAssertNotEqual</code>, <code class="markup--code markup--p-code">XCTAssertNil</code>, and <code class="markup--code markup--p-code">XCTAssertNotNil</code>.</p><p name="a6dd" id="a6dd" class="graf graf--p graf-after--p">Testing is not only for checking if things are as they should be, but also for measuring performance, it’s one of my favorite features because after I perform the first of two-step process of <em class="markup--em markup--p-em">make it work, make it right. </em>This allows me to come back later on and <em class="markup--em markup--p-em">make it fast</em>.</p><figure name="6ce8" id="6ce8" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/mildocjr/a31da914b3f7488bf6e353ba3bdbbca1.js"></script></figure><p name="6a41" id="6a41" class="graf graf--p graf-after--figure">Unlike our assertion tests, we do not need to include an expected return section in our method declaration. Instead, we just replace that with <br><code class="markup--code markup--p-code u-paddingRight0 u-marginRight0">test_<em class="markup--em markup--p-em">functionName</em>Performance()</code>. <code class="markup--code markup--p-code">measure { }</code> block should only contain the code we want to measure. If we were passing in a variable to <code class="markup--code markup--p-code">getFactorial(of:)</code> then we’d instantiate it outside of the measure block unless we wanted to include it in our measurements.</p><p name="2a38" id="2a38" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">_ = getFactorial(of: 45)</code> just calls the <code class="markup--code markup--p-code">getFactorial</code> method with an input of <code class="markup--code markup--p-code">45</code>. Since we don’t need to store the value we just use <code class="markup--code markup--p-code">_ =</code> which is kind of like moving the result to <code class="markup--code markup--p-code">/dev/null</code>. We don’t care what the value is, it’s not important here.</p><p name="9e01" id="9e01" class="graf graf--p graf-after--p">What we do care about is how long it takes for the factorial function to perform its work. When you run this, the test case runs 10 times.</p></div><div class="section-inner sectionLayout--outsetColumn"><figure name="806c" id="806c" class="graf graf--figure graf--layoutOutsetCenter graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 1032px; max-height: 387px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 37.5%;"></div><img class="graf-image" data-image-id="1*KH2uHYMLM6Nxqb20SRY-GA.png" data-width="1922" data-height="720" src="https://cdn-images-1.medium.com/max/1200/1*KH2uHYMLM6Nxqb20SRY-GA.png"></div><figcaption class="imageCaption">Initial measurement</figcaption></figure></div><div class="section-inner sectionLayout--insetColumn"><figure name="e915" id="e915" class="graf graf--figure graf--iframe graf-after--figure"><script src="https://gist.github.com/mildocjr/92efc4b741e47e02bcef036fd50e1d98.js"></script></figure><p name="55ae" id="55ae" class="graf graf--p graf-after--figure">Here’s what our <code class="markup--code markup--p-code">getFactorial(of:)</code> function looks like for reference.</p><p name="f0f6" id="f0f6" class="graf graf--p graf-after--p">For the first run, this performed its function in 0.00000263s. That’s pretty fast but there were optimizations happening during this time, let’s set the baseline and run it again.</p></div><div class="section-inner sectionLayout--outsetColumn"><figure name="78d7" id="78d7" class="graf graf--figure graf--layoutOutsetCenter graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 1032px; max-height: 323px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 31.3%;"></div><img class="graf-image" data-image-id="1*D3aLWqa4BSFDDhY43uuSwA.png" data-width="2248" data-height="704" src="https://cdn-images-1.medium.com/max/1200/1*D3aLWqa4BSFDDhY43uuSwA.png"></div><figcaption class="imageCaption">Second Run</figcaption></figure></div><div class="section-inner sectionLayout--insetColumn"><p name="5f03" id="5f03" class="graf graf--p graf-after--figure">In the second run, we performed this 39% better but nothing changed. This is because the optimizations are already there and we just reused them. This is a good place to set our new baseline so we click edit then accept the new baseline and save it. On subsequent runs, I found variations of 6% worse, 0% better, 2% better, and 7% better without changing a line of code. This is a good baseline for us. From here we could make changes then re-test our measurements to see if we made things better or worse.</p><p name="c00f" id="c00f" class="graf graf--p graf-after--p">While there isn’t a strict guideline for what is considered a good optimization, I consider keeping any change that is consistently better over 10 measurements (100 runs). If it’s significantly better in the first few runs I’ll keep the updated code.</p><p name="a0eb" id="a0eb" class="graf graf--p graf-after--p">When it comes to testing Unit Testing is what we talked about above. There is also general testing which is testing the overall functionality of your app performing as it should. UI Testing is another type of testing that covers your UI but since this tutorial is just about the basics, it is out of scope of this article. Finally, there is user acceptance testing (UAT) which is making sure the users will like what they have. This is typically done by QA teams and the business or a select audience of end users (read about TestFlight). It allows you to throw more scenarios at the application for further testing and keeps the questions down about “How do I _________?” when the app goes live.</p><figure name="c5b1" id="c5b1" class="graf graf--figure graf--startsWithDoubleQuote graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 394px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 56.3%;"></div><img class="graf-image" data-image-id="0*_Pe6ANQX9xKwRnbp." data-width="3200" data-height="1800" src="https://cdn-images-1.medium.com/max/800/0*_Pe6ANQX9xKwRnbp."></div><figcaption class="imageCaption">“A woman in silhouette jumps for joy against dark mountains and a pink and purple sunset.” by <a href="https://unsplash.com/@schmidy?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com/@schmidy?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-creator noopener" target="_blank">Austin Schmid</a> on <a href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-source noopener" target="_blank">Unsplash</a></figcaption></figure><h3 name="4e43" id="4e43" class="graf graf--h3 graf-after--figure">Summary</h3><p name="e5b4" id="e5b4" class="graf graf--p graf-after--h3">We learned the basics of testing and how it can help you write better code, the importance of it in the development cycle and how to measure the performance of your own code. Further testing involves using Xcode Instruments where you can measure memory, CPU, and disk (I/O) usage but it’s more advanced.</p><p name="d901" id="d901" class="graf graf--p graf-after--p">Make sure you write good tests for your application so you always know it will function as expected.</p><h3 name="1707" id="1707" class="graf graf--h3 graf-after--p">What’s Next</h3><p name="ee27" id="ee27" class="graf graf--p graf-after--h3">What’s next is Model View Controller architecture.</p><p name="eb42" id="eb42" class="graf graf--p graf-after--p">Model View Controller (MVC) is used extensively to teach new developers how to code. It’s the easiest way to learn how to use multiple files in a project. While there are others that you can pick from, they might leave you a bit confused. When you are ready to move on from MVC you will almost naturally start writing in a different architecture style based on your App’s needs.</p><p name="54ef" id="54ef" class="graf graf--p graf-after--p">Until then keep practicing!</p><div name="1f73" id="1f73" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://medium.com/@broebling/beginning-swift-programming-part-18-model-view-controller-architecture-dec87c8a6823" data-href="https://medium.com/@broebling/beginning-swift-programming-part-18-model-view-controller-architecture-dec87c8a6823" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.com/@broebling/beginning-swift-programming-part-18-model-view-controller-architecture-dec87c8a6823"><strong class="markup--strong markup--mixtapeEmbed-strong">Beginning Swift Programming Part 18 — Model View Controller architecture</strong><br><em class="markup--em markup--mixtapeEmbed-em">In the last article we talked about writing Tests.</em>medium.com</a><a href="https://medium.com/@broebling/beginning-swift-programming-part-18-model-view-controller-architecture-dec87c8a6823" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="07ce8dfc9b3f8f42e55d1e9149dedbca" data-thumbnail-img-id="0*M3_4HmtW28To2EdF." style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*M3_4HmtW28To2EdF.);"></a></div><figure name="0cb1" id="0cb1" class="graf graf--figure graf-after--mixtapeEmbed graf--trailing"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 280px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 40%;"></div><a href="http://bit.ly/2KkkwGL" data-href="http://bit.ly/2KkkwGL" class="graf-imageAnchor" data-action="image-link" data-action-observe-only="true"rel="noopener"target="_blank"><img class="graf-image" data-image-id="1*5-oC2BqqizoRxIls08WMmA.png" data-width="1250" data-height="500" src="https://cdn-images-1.medium.com/max/800/1*5-oC2BqqizoRxIls08WMmA.png"></a></div></figure></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@broebling" class="p-author h-card">Bob Roebling</a> on <a href="https://medium.com/p/d4ae8e738bf4"><time class="dt-published" datetime="2018-05-12T16:37:53.715Z">May 12, 2018</time></a>.</p><p><a href="https://medium.com/@broebling/beginning-swift-programming-part-17-testing-d4ae8e738bf4" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 1, 2019.</p></footer></article></body></html>