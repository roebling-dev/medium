<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Beginning Python Programming — Part 2</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Beginning Python Programming — Part 2</h1>
</header>
<section data-field="subtitle" class="p-summary">
Reference types, pointers, and collection types
</section>
<section data-field="body" class="e-content">
<section name="6d0c" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="63e8" id="63e8" class="graf graf--h3 graf--leading graf--title">Beginning Python Programming — Part 2</h3><h4 name="fafa" id="fafa" class="graf graf--h4 graf-after--h3 graf--subtitle">Reference types, pointers, and collection types</h4></div><div class="section-inner sectionLayout--outsetColumn"><figure name="ae63" id="ae63" class="graf graf--figure graf--layoutOutsetCenter graf-after--h4"><div class="aspectRatioPlaceholder is-locked" style="max-width: 1032px; max-height: 702px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 68.10000000000001%;"></div><img class="graf-image" data-image-id="0*TIGO3dUA1yew3af4" data-width="5511" data-height="3751" data-unsplash-photo-id="duQ1ulzTJbM" data-is-featured="true" src="https://cdn-images-1.medium.com/max/1200/0*TIGO3dUA1yew3af4"></div><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/@chrislawton?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com/@chrislawton?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-creator noopener noopener" target="_blank">Chris Lawton</a> on <a href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-source noopener noopener" target="_blank">Unsplash</a></figcaption></figure></div><div class="section-inner sectionLayout--insetColumn"><p name="f1ea" id="f1ea" class="graf graf--p graf-after--figure">In <a href="https://medium.com/@broebling/beginning-python-programming-part-1-variables-constants-and-types-1199da1572c8" data-href="https://medium.com/@broebling/beginning-python-programming-part-1-variables-constants-and-types-1199da1572c8" class="markup--anchor markup--p-anchor" target="_blank">part one</a> of our series on Python, we introduced variables, constants, and types. Today, we will be covering reference types, pointers, and collection types!</p><p name="165c" id="165c" class="graf graf--p graf-after--p">In other programming languages, you have this idea of value types. In Python, this concept doesn’t exist. Instead, we just have reference types. As much as I’d like to dive right in, there is this prerequisite which is common to all object-oriented languages but is one of the hardest concepts to grasp called pointers.</p><h3 name="d2e6" id="d2e6" class="graf graf--h3 graf-after--p">Preliminary Stuff</h3><p name="b8ad" id="b8ad" class="graf graf--p graf-after--h3">Last time we talked about memory and how it is arranged in blocks, bytes, and bits. I’d like to expand on that here and give you some visual representations of how memory works.</p><p name="dd1c" id="dd1c" class="graf graf--p graf-after--p">Let’s create a string that holds the value <strong class="markup--strong markup--p-strong">Hello</strong>. Nothing special, we’ve done this before.</p><p name="d3b1" id="d3b1" class="graf graf--p graf-after--p">I told you in the previous article that memory holds the value. If we could look at that memory it would look like this:</p><figure name="1ea6" id="1ea6" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 230px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 32.800000000000004%;"></div><img class="graf-image" data-image-id="1*pjtNnINmLehSTDFbpgvcgg.png" data-width="1042" data-height="342" src="https://cdn-images-1.medium.com/max/800/1*pjtNnINmLehSTDFbpgvcgg.png"></div></figure><p name="ad88" id="ad88" class="graf graf--p graf-after--figure">I bet you’re asking what <code class="markup--code markup--p-code">\0</code> is at the end of the string! That is referred to as a <em class="markup--em markup--p-em">null terminator</em>. The slash tells the program to get ready for a command and the zero stands for nothing. This is how string values are stored and let the program know when the string is finished while still allowing spaces to be used.</p><p name="001f" id="001f" class="graf graf--p graf-after--p">Numbers are a little different.</p><figure name="be7f" id="be7f" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 230px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 32.800000000000004%;"></div><img class="graf-image" data-image-id="1*eaEHygl5FPyOe3Lfodb1GQ.png" data-width="1042" data-height="342" src="https://cdn-images-1.medium.com/max/800/1*eaEHygl5FPyOe3Lfodb1GQ.png"></div></figure><p name="0ea5" id="0ea5" class="graf graf--p graf-after--figure">Numbers are stored as binary numbers. Binary is easy to understand, start at 1 in the far right of the memory block and work your way left, multiplying the current value by 2 every time. If you are familiar with graphics cards or memory sticks, it’s why we see 8-bit (Atari, NES), 16-bit (Sega Genesis, SNES), 32-bit (PlayStation), 64-bit (Nintendo 64), and so on.</p><p name="396f" id="396f" class="graf graf--p graf-after--p">In binary, if a position is 0, it is off, it’s false. If a position is 1, it’s on, or true.<br>Based on this logic we only need to count the positions with a 1 in them. Can you figure out the number in the image above?</p><p name="9494" id="9494" class="graf graf--p graf-after--p">Now, this is a group of 8 bits of memory, that’s right, it is a full byte of memory. Previously I said each character in a string was 2 bytes, that means we used 16 bits to store a character. 16-bits in binary gives us the maximum value of 128. However, when we talk about positions, we always start with 0. So 16-bits gives you a full range of <code class="markup--code markup--p-code">0-127</code>. If you are wondering how we can get characters out of that range, I’ll point you to the <a href="http://www.asciitable.com" data-href="http://www.asciitable.com" class="markup--anchor markup--p-anchor" rel="noopener nofollow noopener noopener noopener noopener" target="_blank">ASCII table</a> where you can see the values for yourself. You’ll even see the hidden characters such as the null terminator <code class="markup--code markup--p-code">/0</code> as shown above.</p><figure name="ef91" id="ef91" class="graf graf--figure graf--layoutOutsetLeft graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 193px; max-height: 342px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 177.2%;"></div><img class="graf-image" data-image-id="1*ZWtMdrzlWjyEkrDUXMRWqA.png" data-width="193" data-height="342" src="https://cdn-images-1.medium.com/max/600/1*ZWtMdrzlWjyEkrDUXMRWqA.png"></div></figure><p name="3d3c" id="3d3c" class="graf graf--p graf-after--figure">Memory stores values in three places: <em class="markup--em markup--p-em">static </em>memory, the <em class="markup--em markup--p-em">stack</em>, and the <em class="markup--em markup--p-em">heap.</em></p><p name="7dcd" id="7dcd" class="graf graf--p graf-after--p">Static memory and stack memory are quickly accessed, however accessing things from the heap is slow (in computer time). While it may not seem slow to you, what could take a millisecond or less to load from the stack, could take 10 ms to load from the heap. In most languages, you’d be able to choose where a variable is instantiated by its type. In Python, the interpreter (the underlying engine) looks at your code and makes assumptions about where the variable should be stored in memory by its <em class="markup--em markup--p-em">scope. </em>Its too early to talk about scope, but I promise we will talk about it in a future article.</p><p name="b03e" id="b03e" class="graf graf--p graf-after--p">Without further ado, let’s dig in.</p><h3 name="50a2" id="50a2" class="graf graf--h3 graf-after--p">Reference Types and Pointers</h3><p name="4c2f" id="4c2f" class="graf graf--p graf-after--h3">Reference types use pointers to store values in memory. Before we go too in-depth on how you use them, we really need to cover pointers.</p><p name="74d9" id="74d9" class="graf graf--p graf-after--p">If you look at a typical C program, you’ll see pointers used everywhere.</p><figure name="c94b" id="c94b" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/mildocjr/f122bede7e78f4b9caf123524201a8f2.js"></script></figure><p name="4e5d" id="4e5d" class="graf graf--p graf-after--figure">When we use <code class="markup--code markup--p-code">char *name = “Bob&quot;;</code>, we make a pointer by using <code class="markup--code markup--p-code">*</code>. This tells the system, give me an <em class="markup--em markup--p-em">address</em> where I can store this value in memory. The system then says “O.K., you can use block 3 for your value.” You then save <code class="markup--code markup--p-code">&quot;Bob&quot;</code> in block 3 (without quotes of course).</p><p name="c9fd" id="c9fd" class="graf graf--p graf-after--p">If you asked for the value of name using <code class="markup--code markup--p-code">printf(&quot;%x&quot;, name);</code>, you’d just see the address, which may look something like <code class="markup--code markup--p-code">0x03</code> only much longer. This is the <em class="markup--em markup--p-em">hexadecimal</em> representation of that block of memory. If you want the value <code class="markup--code markup--p-code">Bob</code> then you’d have to use <code class="markup--code markup--p-code">printf(*name);</code> (both print statements are in C).</p><p name="1fba" id="1fba" class="graf graf--p graf-after--p">In C, if you wanted to change the value from anywhere you would use <code class="markup--code markup--p-code">&amp;name </code>, which says to take the address of this value and do something with it. As the value changes, you can use it immediately with the new value by referencing <code class="markup--code markup--p-code">*name</code>.</p><p name="71c1" id="71c1" class="graf graf--p graf-after--p">Under the hood, Python looks at your variables and does all of this <code class="markup--code markup--p-code">*</code> magic for you. It makes every programmer&#39;s job easier because of it. Because it handles all of this for you, you don’t have to worry as much about creating memory leaks, however, you do still need to worry about something called race conditions which we will cover later on.</p><p name="8129" id="8129" class="graf graf--p graf-after--p">The reason why I bring up reference types is because of the more advanced types that we will cover in the next part of this series. I just want you to be familiar with how reference types work before we get started.</p><p name="1d66" id="1d66" class="graf graf--p graf-after--p">The way that I remember reference types is by imagining a treasure chest. It doesn’t belong to anyone, but as soon as I find it, I write down where it is so I can come back to it any time I want. If I want to look at the map to see where it is or to tell someone else, I use <code class="markup--code markup--p-code">&amp;</code>. If I want to open it and look at the treasure inside, I use <code class="markup--code markup--p-code">*</code>. If I want to put something inside it or take something out, I still have to use <code class="markup--code markup--p-code">*</code> to get to it first.</p><p name="5fa3" id="5fa3" class="graf graf--p graf-after--p">When you store a value such as <code class="markup--code markup--p-code">Bob</code> in a C pointer, you actually put each letter in a separate piece of memory. All you really know is where <code class="markup--code markup--p-code">B</code> is; the null terminator <code class="markup--code markup--p-code">/0</code> tells the computer when to stop <em class="markup--em markup--p-em">iterating</em> through pieces of memory and return whatever value it has. Think of it as a one button combo in Street Fighter. I’ll talk more about this when we get to collection types, if you make the connection as to how strings work in C (also called C-Strings) based on the type I will be presenting, then you are correct.</p><p name="c8e7" id="c8e7" class="graf graf--p graf-after--p">As we continue, you’ll have some ideas. If you want to learn C, C++ or Objective-C this is all very important information, however, with Python, they hide all of this complexity very well so you hardly ever have to worry about the <code class="markup--code markup--p-code">&amp;</code> or the <code class="markup--code markup--p-code">*</code> <em class="markup--em markup--p-em">operator</em>.</p><p name="193a" id="193a" class="graf graf--p graf-after--p">Reference types can be stored in either the stack or on the heap. You’ll know if a reference type is stored on the heap if memory is manually allocated by the programmer for it using <code class="markup--code markup--p-code">malloc</code>.*</p><p name="3cda" id="3cda" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">*Any variable created with malloc will not go away on its own when the program ends, you must call </em><code class="markup--code markup--p-code"><em class="markup--em markup--p-em">dealloc</em></code><em class="markup--em markup--p-em"> or </em><code class="markup--code markup--p-code"><em class="markup--em markup--p-em">free</em></code><em class="markup--em markup--p-em"> depending on your language in order to remove the value from memory, otherwise, it will stay in memory until the computer is restarted. This is what is referred to as a “memory leak”.</em></p><p name="b9e0" id="b9e0" class="graf graf--p graf-after--p">Python handles all of this for you, so you don’t have to worry about <code class="markup--code markup--p-code">malloc</code>, <code class="markup--code markup--p-code">dealloc</code>, or <code class="markup--code markup--p-code">free</code>. There is one exception where you can use <code class="markup--code markup--p-code">del</code> to clear memory where a variable is stored, but you usually don’t need to use this.</p></div><div class="section-inner sectionLayout--outsetColumn"><figure name="167c" id="167c" class="graf graf--figure graf--layoutOutsetCenter graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 1032px; max-height: 684px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 66.2%;"></div><img class="graf-image" data-image-id="0*3rEaL5dm8LbU05w4" data-width="3000" data-height="1987" data-unsplash-photo-id="HRc9JE3VJCg" src="https://cdn-images-1.medium.com/max/1200/0*3rEaL5dm8LbU05w4"></div><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/@kellysikkema?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com/@kellysikkema?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-creator noopener noopener" target="_blank">Kelly Sikkema</a> on <a href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-source noopener noopener" target="_blank">Unsplash</a></figcaption></figure></div><div class="section-inner sectionLayout--insetColumn"><h3 name="4fd0" id="4fd0" class="graf graf--h3 graf-after--figure">Collection Types</h3><p name="b8fb" id="b8fb" class="graf graf--p graf-after--h3">Collection types are types that contain a collection of items. There are two main types: <em class="markup--em markup--p-em">lists </em>and <em class="markup--em markup--p-em">dictionaries.</em> Some languages refer to lists as <em class="markup--em markup--p-em">arrays.</em> If you are needing to translate code between an example in another language and Python, know that these refer to the same type of collection.</p><ol class="postList"><li name="d959" id="d959" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Lists</strong> — Lists contain ordered like elements which are <em class="markup--em markup--li-em">addressable</em> by their index. The index is defined by the number of items from the beginning of the list. If we defined a list as such: <br><code class="markup--code markup--li-code">my_list = [&quot;eggs&quot;, &quot;milk&quot;, &quot;butter&quot;, &quot;cheese&quot;]</code> <br>we are able to retrieve each of those values by using <code class="markup--code markup--li-code">‘my_list[0]’</code>, which would give us the value <code class="markup--code markup--li-code">eggs</code> because it’s 0 places from the start of the list. Using this logic, if we wanted <code class="markup--code markup--li-code">butter</code>, we would use <code class="markup--code markup--li-code">my_list[2]</code> because it is <code class="markup--code markup--li-code">2</code>places away from <code class="markup--code markup--li-code">eggs</code>.<br>If we wanted to change the value stored in a list we could use <br><code class="markup--code markup--li-code">my_list[2] = &quot;Sugar&quot;</code>.<br>In C-Strings this surprisingly makes a little more sense. When we stored <code class="markup--code markup--li-code">Bob</code> in a C-string, we actually made an <em class="markup--em markup--li-em">array</em> of characters (hence the char type). If we said <code class="markup--code markup--li-code">name[0]</code> it would just return <code class="markup--code markup--li-code">B</code> because it was 0 pieces of memory from the start of the array. If you go outside of the array you will run into problems. Most of the time the computer will save you saying “index out of range” or something similar to that. If you run into this issue while your program is running, it will crash.<br>More specific to Python, you can use slices of lists using the following syntax:<br><code class="markup--code markup--li-code">my_list[1:3]</code> which will return the 2nd and 3rd items in the list.<br>You can also use open-ended ranges with the following examples:<br><code class="markup--code markup--li-code">my_list[:2]</code> returns everything from the start to the second item in the list, <code class="markup--code markup--li-code">my_list[1:]</code> starts at the second element and continues to the end.<br>The way this can be understood is:<br><code class="markup--code markup--li-code">my_list[&lt;start position&gt;:&lt;stop position — 1&gt;]<br></code>You can also use negative numbers to exclude values at the end.<br><code class="markup--code markup--li-code">my_list[:-2]</code> returns everything but the last two elements of the list.<br>Lists can contain any type of variable, so <code class="markup--code markup--li-code">[True&#39;, &#39;three&#39;, 3]</code>, that is a boolean, a string, and a number, is still a valid list. Thanks <a href="https://medium.com/u/66a601633f9c" data-href="https://medium.com/u/66a601633f9c" data-anchor-type="2" data-user-id="66a601633f9c" data-action-value="66a601633f9c" data-action="show-user-card" data-action-type="hover" class="markup--user markup--li-user" target="_blank">Greg</a>.</li><li name="9e37" id="9e37" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Dictionaries</strong> — I’ll give you one guess at why this is named the way it is. Dictionaries are similar to arrays in that they contain values of a common type, however, they are different as they are unordered. They do contain an index but the index is typically a string value. With that in mind, you might be thinking of a word in the dictionary followed by its definition. That’s about how it works! You can define a dictionary using the following:<br><code class="markup--code markup--li-code">my_dictionary = {&quot;Kevin&quot;: &quot;Lead Minion&quot;, &quot;Bob&quot;, &quot;Determined Minion&quot;, &quot;Stewart&quot;: &quot;Rocker Minion&quot;}</code> <br>The <code class="markup--code markup--li-code">:</code> separates the key from the value.<br>We can get at the value of any one of these by using: <code class="markup--code markup--li-code">my_dictionary[&quot;Kevin&quot;]</code><br>You can set the value in a dictionary using the same syntax as a list just using the <em class="markup--em markup--li-em">key</em> to set the <em class="markup--em markup--li-em">value. </em>Python doesn’t care about ensuring the values are of the same type, for instance:<br><code class="markup--code markup--li-code">my_dictionary[&quot;Bob&quot;] = &quot;King Bob&quot;</code> is allowed. <br><code class="markup--code markup--li-code">my_dictionary[&quot;Bob&quot;] = 2</code> is also allowed.<br>You can declare and instantiate dictionaries by using <br><code class="markup--code markup--li-code">my_dictionary = {}</code>.</li></ol><p name="442c" id="442c" class="graf graf--p graf-after--li">Dictionaries and Lists are used extensively in Python. You need to be careful with lists to stay within the bounds of its elements. If you try to access a value that doesn’t exist in a dictionary, you’ll receive a <code class="markup--code markup--p-code">KeyValue</code> error.</p><h3 name="8e83" id="8e83" class="graf graf--h3 graf-after--p">Summary</h3><p name="b46d" id="b46d" class="graf graf--p graf-after--h3">Today we learned about reference types, collection types, and a little bit more about memory.</p><h3 name="bb9a" id="bb9a" class="graf graf--h3 graf-after--p">What’s Next</h3><p name="e52b" id="e52b" class="graf graf--p graf-after--h3">In the next post, we will go over operators and <code class="markup--code markup--p-code">None</code>. Most of the preliminary background information is over, and soon we will be having fun with programming.</p><div name="c874" id="c874" class="graf graf--mixtapeEmbed graf-after--p graf--trailing"><a href="https://medium.com/@broebling/beginning-python-programming-part-3-operators-and-none-3a80de041411" data-href="https://medium.com/@broebling/beginning-python-programming-part-3-operators-and-none-3a80de041411" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.com/@broebling/beginning-python-programming-part-3-operators-and-none-3a80de041411"><strong class="markup--strong markup--mixtapeEmbed-strong">Beginning Python Programming Part 3 — Operators and None</strong><br><em class="markup--em markup--mixtapeEmbed-em">In the last post, we covered reference types, pointers, and collection types.</em>medium.com</a><a href="https://medium.com/@broebling/beginning-python-programming-part-3-operators-and-none-3a80de041411" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="3b143d282360646630ee169a1e07dc62" data-thumbnail-img-id="0*gs6meuDGK-8-zvkL" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*gs6meuDGK-8-zvkL);"></a></div></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@broebling" class="p-author h-card">Bob Roebling</a> on <a href="https://medium.com/p/a806ef6b92cf"><time class="dt-published" datetime="2019-05-19T21:26:41.895Z">May 19, 2019</time></a>.</p><p><a href="https://medium.com/@broebling/beginning-python-programming-part-2-reference-types-pointers-and-collection-types-a806ef6b92cf" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 1, 2019.</p></footer></article></body></html>