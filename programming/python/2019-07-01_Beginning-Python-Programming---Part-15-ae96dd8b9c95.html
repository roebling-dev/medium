<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Beginning Python Programming — Part 15</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Beginning Python Programming — Part 15</h1>
</header>
<section data-field="subtitle" class="p-summary">
An introduction to multi-processing
</section>
<section data-field="body" class="e-content">
<section name="8db2" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="af51" id="af51" class="graf graf--h3 graf--leading graf--title">Beginning Python Programming — Part 15</h3><h4 name="a5f1" id="a5f1" class="graf graf--h4 graf-after--h3 graf--subtitle">An introduction to multi-processing</h4></div><div class="section-inner sectionLayout--outsetColumn"><figure name="c710" id="c710" class="graf graf--figure graf--layoutOutsetCenter graf-after--h4"><div class="aspectRatioPlaceholder is-locked" style="max-width: 1032px; max-height: 687px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 66.60000000000001%;"></div><img class="graf-image" data-image-id="0*IyqUsB_yVwFp07kD" data-width="6028" data-height="4012" data-unsplash-photo-id="S4jSvcHYcOs" data-is-featured="true" src="https://cdn-images-1.medium.com/max/1200/0*IyqUsB_yVwFp07kD"></div><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/@briankost?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com/@briankost?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-creator noopener noopener noopener noopener noopener" target="_blank">Brian Kostiuk — @BriKost</a> on <a href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-source noopener noopener noopener noopener noopener" target="_blank">Unsplash</a></figcaption></figure></div><div class="section-inner sectionLayout--insetColumn"><p name="ba21" id="ba21" class="graf graf--p graf-after--figure">In the previous article, we covered multi-threading.</p><div name="b0b6" id="b0b6" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://medium.com/better-programming/beginning-python-programming-part-14-208b9fa2f0a1" data-href="https://medium.com/better-programming/beginning-python-programming-part-14-208b9fa2f0a1" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.com/better-programming/beginning-python-programming-part-14-208b9fa2f0a1"><strong class="markup--strong markup--mixtapeEmbed-strong">Beginning Python Programming — Part 14</strong><br><em class="markup--em markup--mixtapeEmbed-em">An introduction to multi-threading</em>medium.com</a><a href="https://medium.com/better-programming/beginning-python-programming-part-14-208b9fa2f0a1" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="a02e58e970c471af6da680960f00f8b9" data-thumbnail-img-id="0*QOCJvi257uMJQh4X" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*QOCJvi257uMJQh4X);"></a></div><p name="5d7f" id="5d7f" class="graf graf--p graf-after--mixtapeEmbed">Here we will be covering another library provided by Python called <code class="markup--code markup--p-code">multiprocessing</code>. Like<code class="markup--code markup--p-code">threading</code>, <code class="markup--code markup--p-code">multiprocessing</code> allows us to run code concurrently; however, this code runs on multiple processors. Let’s start with a definition.</p><ul class="postList"><li name="e0a8" id="e0a8" class="graf graf--li graf-after--p">Global Interpreter Lock (GIL) — used to ensure that Python bytecode only runs on one thread at a time when <em class="markup--em markup--li-em">locked</em>. If <em class="markup--em markup--li-em">released</em>, it allows using multiple cores for processing.</li></ul><p name="47de" id="47de" class="graf graf--p graf-after--li">So far, we’ve been able to dodge this complexity, as we have only been dealing with single core computations. The GIL is vital to ensure the safety of concurrent access; in layman’s terms, multiple tasks do not cause problems when running at the same time.</p><p name="940a" id="940a" class="graf graf--p graf-after--p">In our previous examples, we ended up having two lines printed to the console at the same time. The GIL could be used to clean this up by ensuring only one process can write to the console at a time.</p><p name="3e01" id="3e01" class="graf graf--p graf-after--p">While the GIL works to protect us, it limits us from the parallel processing that we get by using multiple cores, which in turn causes performance issues. It doesn’t mean “never use the multiprocessing,” it just means that we should only use multi-processing when we know exactly how we want our code to perform.</p><h3 name="818f" id="818f" class="graf graf--h3 graf-after--p">Multiprocessing</h3><p name="ed32" id="ed32" class="graf graf--p graf-after--h3"><code class="markup--code markup--p-code">multiprocessing</code> is best used when we are performing CPU-based calculations. CPU calculations might be Bitcoin mining (the slow way) or creating rainbow tables for some extreme examples. Some more practical examples are photo and video editing, music composition, or creating hash tables (data mining stuff).</p><p name="eee1" id="eee1" class="graf graf--p graf-after--p">Here’s an example you’ll recognize from the previous post slightly changed to work for multiprocessing.</p><figure name="dc74" id="dc74" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/mildocjr/b44a1775570a5e1662cf8a028e154736.js"></script></figure><p name="a01c" id="a01c" class="graf graf--p graf-after--figure">Instead of importing <code class="markup--code markup--p-code">threading</code> and <code class="markup--code markup--p-code">concurrent.futures</code>, we only need to import <code class="markup--code markup--p-code">multiprocessing</code>. The next thing that has changed is that I used <code class="markup--code markup--p-code">multiprocessing.current_process().pid</code> instead of <code class="markup--code markup--p-code">threading.active_count().name[-3:]</code>. This gets the Process ID of the process that spun from our main process and reports it back to the console, so we know where to find our process if we ever need to terminate it later. Everything else in our <code class="markup--code markup--p-code">task</code> function is the same.</p><p name="fa5b" id="fa5b" class="graf graf--p graf-after--p">In <code class="markup--code markup--p-code">main</code>, we changed our executor, which once stood as an instance of <code class="markup--code markup--p-code">ThreadPoolExecutor</code>, but we changed it to <code class="markup--code markup--p-code">multiprocessing.Pool()</code>. Here, we specified only a single process should be used. If I left it blank, it would return the total number of CPUs available in my machine using <code class="markup--code markup--p-code">os.cpu_count()</code>.</p><p name="48c5" id="48c5" class="graf graf--p graf-after--p">Like threading, I am using <code class="markup--code markup--p-code">map</code> to map each <code class="markup--code markup--p-code">number</code> to its own <code class="markup--code markup--p-code">task</code>. If I have more tasks than processes, they will queue up and wait for the previous task to complete. Finally, I added <code class="markup--code markup--p-code">executor.close()</code> because I had a runaway process. <code class="markup--code markup--p-code">close()</code> cleans up the pool and ensures it is properly stopped.</p><p name="108b" id="108b" class="graf graf--p graf-after--p">In <code class="markup--code markup--p-code">if __name__ == “__main__&quot;</code>, we removed the line <code class="markup--code markup--p-code">current_threads = threading.active_count()</code>. We did not replace it with the equivalent line for multiprocessing, which would be<code class="markup--code markup--p-code">current_children = multiprocessing.active_children()</code>, because our executor will block the main thread until it is completed. We could run this using a more true <code class="markup--code markup--p-code">apply_async</code> call (similar to <code class="markup--code markup--p-code">start</code>), but for our purposes, we won’t need it here.</p><p name="25ef" id="25ef" class="graf graf--p graf-after--p">I also continue to use <code class="markup--code markup--p-code">time</code> to check our execution run time as we did previously.</p><p name="d0f5" id="d0f5" class="graf graf--p graf-after--p">Here are the results of testing multiple processes:</p></div><div class="section-inner sectionLayout--outsetColumn"><figure name="055f" id="055f" class="graf graf--figure graf--layoutOutsetCenter graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 1032px; max-height: 558px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 54.1%;"></div><img class="graf-image" data-image-id="1*WNzSYFurh3AHmheEhly_5g.png" data-width="1576" data-height="852" src="https://cdn-images-1.medium.com/max/1200/1*WNzSYFurh3AHmheEhly_5g.png"></div><figcaption class="imageCaption">Run times (in seconds) for the total number of processes used.</figcaption></figure></div><div class="section-inner sectionLayout--insetColumn"><p name="e6ab" id="e6ab" class="graf graf--p graf-after--figure">We get a better run time here than we did with threading. This isn’t always the case, so be sure to run your own tests before you decide. Our time here is 3.05 seconds. Previously, we hit 3.09 with 50 threads. This must mean that multiprocessing knows how to take advantage of using multiple threads.</p><p name="d095" id="d095" class="graf graf--p graf-after--p">Like threading, we see our most significant jump when we use two processes. We also see other noticeable drops until we get to 4 cores. Between 4 and 7 processes, we don’t see much of a difference; however, at 8 processes, we see another noticeable dip. This lack of difference was probably due to my computer doing other things (ahem, writing this article), which already used up CPU time through Chrome, Safari, PyCharm (for code quality), and Mail, not to mention all of that stuff that runs in the background.</p><p name="37ef" id="37ef" class="graf graf--p graf-after--p">I added 10 and 16 processes to show what happens when you use more processes than CPUs. We see that number creep back up, not an improvement.</p><p name="d918" id="d918" class="graf graf--p graf-after--p">You might want to add some code like this to combat putting code on a system where you may not know how many CPUs it will have.</p><figure name="9904" id="9904" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/mildocjr/ea302bc68c0b92370b58d80548b45906.js"></script></figure><p name="6945" id="6945" class="graf graf--p graf-after--figure graf--trailing">I know there are other ways to do this, using <code class="markup--code markup--p-code">elif</code> or a ternary operator, but this is straightforward, and it works. <code class="markup--code markup--p-code">os.cpu_count()</code> might be expensive, which is why I stored it in a variable. This way, I’m not asking Python to look up the CPU count every time I need to do a comparison or an assignment.</p></div></div></section><section name="70c1" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="5872" id="5872" class="graf graf--h3 graf--leading">Locks</h3><p name="dfcb" id="dfcb" class="graf graf--p graf-after--h3">Since we have an opportunity for two different processes to print to the console at one time, we might want to include locks in our program.</p><p name="7ffa" id="7ffa" class="graf graf--p graf-after--p">I’ll use the same example from above to show how locks work.</p><figure name="2b07" id="2b07" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/mildocjr/1711dedbd1ed499e132245dfdf8d2a53.js"></script></figure><p name="8cc8" id="8cc8" class="graf graf--p graf-after--figure">What <code class="markup--code markup--p-code">Lock</code> does is it <em class="markup--em markup--p-em">acquires</em> a lock on the console process. While the lock is active, no other process can use this. A <code class="markup--code markup--p-code">Lock</code> is used when editing files, and I’m sure you’ve seen the warning, <em class="markup--em markup--p-em">some user</em> has <em class="markup--em markup--p-em">some file</em> opened, please ask them to close it or try again later. This is the same kind of lock we are talking about here. Lock prevents anyone else from accessing the console until the process has <em class="markup--em markup--p-em">released</em> the lock on the console.</p><p name="be68" id="be68" class="graf graf--p graf-after--p">Locks do cause our run time to increase but not by much. In this example, my run time increased from 0.87 to 1.01 seconds. I’ll take ~0.2 seconds for more safety around data output.</p></div><div class="section-inner sectionLayout--outsetColumn"><figure name="6019" id="6019" class="graf graf--figure graf--layoutOutsetCenter graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 1032px; max-height: 688px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 66.7%;"></div><img class="graf-image" data-image-id="0*rix8pbqgN70gpKmR" data-width="6000" data-height="4000" data-unsplash-photo-id="aZOqcEK2KuQ" src="https://cdn-images-1.medium.com/max/1200/0*rix8pbqgN70gpKmR"></div><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/@hero?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com/@hero?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-creator noopener noopener" target="_blank">Herson Rodriguez</a> on <a href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-source noopener noopener" target="_blank">Unsplash</a></figcaption></figure></div><div class="section-inner sectionLayout--insetColumn"><h3 name="8421" id="8421" class="graf graf--h3 graf-after--figure">Sharing</h3><p name="8183" id="8183" class="graf graf--p graf-after--h3">Sometimes we need to share data between processes. There are a few ways to do this, but it’s not as straightforward. When I first started with multiprocessing, I saw a lot of new error messages that seemed cryptic because I wasn’t familiar with socket programming. While that is out of the scope of this tutorial, I’ll try to keep it simple enough so that you can share data between processes. It’s up to you to learn the advanced stuff on your own.</p><figure name="a934" id="a934" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/mildocjr/e55444732bf01b9441b6b7865e208a03.js"></script></figure><p name="2d88" id="2d88" class="graf graf--p graf-after--figure">Here we have a modified example from the previous threading article. We start with a few direct imports: <code class="markup--code markup--p-code">Process</code>, <code class="markup--code markup--p-code">Queue</code>, and <code class="markup--code markup--p-code">current_process</code>.</p><p name="933f" id="933f" class="graf graf--p graf-after--p">I modified our <code class="markup--code markup--p-code">count</code> function slightly. Before I get into the details, I want to cover multiprocessing queues. Queues also exist in the <a href="https://docs.python.org/3/library/threading.html" data-href="https://docs.python.org/3/library/threading.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Threading</a> library; however, there isn’t as straightforward of a way to share values because processes run in separate memory spaces. This is where queues come into play. You attach queues to processes to allow transporting values from one process to another.</p><p name="09a8" id="09a8" class="graf graf--p graf-after--p">To insert values into a queue, we use <code class="markup--code markup--p-code">queue.put(item)</code>. To retrieve values, we use <code class="markup--code markup--p-code">queue.get()</code>. The way that queues work is first-in-first-out or FIFO, meaning the first item you <code class="markup--code markup--p-code">put</code> into a queue is what you will get back the first time you call <code class="markup--code markup--p-code">get()</code>.</p><p name="37ca" id="37ca" class="graf graf--p graf-after--p">Back to our example. <code class="markup--code markup--p-code">count</code> previously required four parameters. Because <code class="markup--code markup--p-code">current_process().name</code> returns “process-1”, “process-2”, etc., we can disregard passing the current process count. Everything else is the same until we get to the end where we <code class="markup--code markup--p-code">put</code> this result in the queue.</p><p name="5c6e" id="5c6e" class="graf graf--p graf-after--p">The first step of our program is to create a <code class="markup--code markup--p-code">queue</code> that we can use for sharing data between processes. Next, we create empty lists to hold our <code class="markup--code markup--p-code">results</code> and <code class="markup--code markup--p-code">processes</code>. Finally, we create a variable to hold the number of processes that we want to use for this calculation with <code class="markup--code markup--p-code">process_count</code>. We do this so that if we ever need to bump up or take out some processes, we can do it all in one place to makes updates easy down the road.</p><p name="3fd3" id="3fd3" class="graf graf--p graf-after--p">We updated how we create new processes by passing the <code class="markup--code markup--p-code">queue</code> instead of the <code class="markup--code markup--p-code">results</code> list. Starting each process in the second loop is still the same as before. In the third loop, we make a couple of changes. Before we can use <code class="markup--code markup--p-code">process.join()</code>, we need to get each value out of our <code class="markup--code markup--p-code">queue</code> and store it in our <code class="markup--code markup--p-code">results</code> list.</p><p name="6d08" id="6d08" class="graf graf--p graf-after--p">Finally, we use <code class="markup--code markup--p-code">queue.close()</code> to ensure we clean up after ourselves, then we finish by printing out the length of the first element in the <code class="markup--code markup--p-code">results</code> list.</p></div><div class="section-inner sectionLayout--outsetColumn"><figure name="a551" id="a551" class="graf graf--figure graf--layoutOutsetCenter graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 1032px; max-height: 686px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 66.5%;"></div><img class="graf-image" data-image-id="0*uOrtko0hym8BBbNx" data-width="3008" data-height="2000" data-unsplash-photo-id="rzBg9N9JTsE" src="https://cdn-images-1.medium.com/max/1200/0*uOrtko0hym8BBbNx"></div><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/@cbarbalis?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com/@cbarbalis?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-creator noopener noopener" target="_blank">Chris Barbalis</a> on <a href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-source noopener noopener" target="_blank">Unsplash</a></figcaption></figure></div><div class="section-inner sectionLayout--insetColumn"><h3 name="db8f" id="db8f" class="graf graf--h3 graf-after--figure">Differences in Async Methods</h3><p name="8548" id="8548" class="graf graf--p graf-after--h3">Now that we’ve covered the different async options we have available, let’s look at the most important aspect: when to use them.</p><h4 name="e5ce" id="e5ce" class="graf graf--h4 graf-after--p">Threading</h4><ul class="postList"><li name="a230" id="a230" class="graf graf--li graf-after--h4">Data can be shared easily between threads.</li><li name="bd0d" id="bd0d" class="graf graf--li graf-after--li">Best used when you are limited by I/O (e.g., disk read/write) but have many connections.</li><li name="29a5" id="29a5" class="graf graf--li graf-after--li">Only uses one CPU core.</li></ul><h4 name="e7ed" id="e7ed" class="graf graf--h4 graf-after--li">Multiprocessing</h4><ul class="postList"><li name="6b47" id="6b47" class="graf graf--li graf-after--h4">Uses multiple CPU cores.</li><li name="610f" id="610f" class="graf graf--li graf-after--li">Able to write to many disks at once.</li><li name="a432" id="a432" class="graf graf--li graf-after--li">Best when you need to perform many calculations very quickly.</li><li name="2714" id="2714" class="graf graf--li graf-after--li">Unless specified only uses one thread in additional cores. (Code can get messy quickly if you don’t have a good design planned)</li><li name="5cec" id="5cec" class="graf graf--li graf-after--li">Sharing data between processes is difficult.</li></ul><h4 name="f100" id="f100" class="graf graf--h4 graf-after--li">Asyncio</h4><ul class="postList"><li name="6240" id="6240" class="graf graf--li graf-after--h4">Relies on threading, but the thread delegates tasks to the system to perform work and results from the delegated tasks.</li><li name="988e" id="988e" class="graf graf--li graf-after--li">When paired with multiprocessing, you can use all cores effectively with multiple threads delegating to the system.</li><li name="e1eb" id="e1eb" class="graf graf--li graf-after--li">Best for when you have slow I/O but need many connections (e.g., web server or web crawler).</li><li name="3468" id="3468" class="graf graf--li graf-after--li">Not suitable for CPU-based tasks because it relies on threading.</li></ul><h3 name="d7bc" id="d7bc" class="graf graf--h3 graf-after--li">Summary</h3><p name="1c97" id="1c97" class="graf graf--p graf-after--h3">Today we learned about multiprocessing and how it can be used to perform calculations very quickly. We did a little more data science and saw that it cut the processing time down by a lot when we switched from threading to multiprocessing in the example, which was a CPU-based task.</p><p name="c49a" id="c49a" class="graf graf--p graf-after--p">We also looked at how we could share data between processes. While it may seem easy because the example is there for you, it took me a while to get it right the first time I tried using multiprocessing. As you write more multiprocessing code, it will get easier. So keep practicing.</p><p name="ef6a" id="ef6a" class="graf graf--p graf-after--p">Finally, we recapped all of the different ways to write async code and looked at a few tips to help us remember which tool is right for the job.</p><h4 name="8467" id="8467" class="graf graf--h4 graf-after--p">Suggested Reading and Viewing</h4><p name="9428" id="9428" class="graf graf--p graf-after--h4">Multiprocessing from the Python docs.</p><div name="b4e9" id="b4e9" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://docs.python.org/3.7/library/multiprocessing.html" data-href="https://docs.python.org/3.7/library/multiprocessing.html" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://docs.python.org/3.7/library/multiprocessing.html"><strong class="markup--strong markup--mixtapeEmbed-strong">multiprocessing — Process-based parallelism — Python 3.7.4rc1 documentation</strong><br><em class="markup--em markup--mixtapeEmbed-em">The module also introduces APIs which do not have analogs in the module. A prime example of this is the object which…</em>docs.python.org</a><a href="https://docs.python.org/3.7/library/multiprocessing.html" class="js-mixtapeImage mixtapeImage mixtapeImage--empty u-ignoreBlock" data-media-id="952eb0256061c8aba3d1f4b2a0fb2838"></a></div><p name="68e7" id="68e7" class="graf graf--p graf-after--mixtapeEmbed">Global Interpreter Lock from the Python wiki.</p><div name="55ca" id="55ca" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://wiki.python.org/moin/GlobalInterpreterLock" data-href="https://wiki.python.org/moin/GlobalInterpreterLock" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://wiki.python.org/moin/GlobalInterpreterLock"><strong class="markup--strong markup--mixtapeEmbed-strong">GlobalInterpreterLock — Python Wiki</strong><br><em class="markup--em markup--mixtapeEmbed-em">In CPython, the global interpreter lock, or GIL, is a mutex that protects access to Python objects, preventing multiple…</em>wiki.python.org</a><a href="https://wiki.python.org/moin/GlobalInterpreterLock" class="js-mixtapeImage mixtapeImage mixtapeImage--empty u-ignoreBlock" data-media-id="98d42a29af38264605d1c868c9b2ec43"></a></div><p name="30df" id="30df" class="graf graf--p graf-after--mixtapeEmbed">Raymond Hettinger, Keynote on Concurrency — PyBay 2017</p><figure name="963e" id="963e" class="graf graf--figure graf--iframe graf-after--p"><iframe src="https://www.youtube.com/embed/9zinZmE3Ogk?feature=oembed" width="700" height="393" frameborder="0" scrolling="no"></iframe></figure><h3 name="ddc2" id="ddc2" class="graf graf--h3 graf-after--figure">What’s Next?</h3><p name="aec0" id="aec0" class="graf graf--p graf-after--h3">After all of that, we’re running low on topics. We’ve covered most of the things in the Python tutorial and some things that are not included. I’ve decided that I don’t want to cover the Standard Library. That happens naturally as you write code and would overload you if I did.</p><p name="accf" id="accf" class="graf graf--p graf-after--p">We do need to cover one critical aspect of all programming languages. Testing!</p><p name="ec46" id="ec46" class="graf graf--p graf-after--p">Yes, you can write a program without writing tests, and it will work (see previous examples here). Testing is by far the most important thing you will do for your application.</p><p name="2169" id="2169" class="graf graf--p graf-after--p">But let’s face it, even if your app is designed to do some <em class="markup--em markup--p-em">amazing</em> <em class="markup--em markup--p-em">things</em>, it is utterly useless if it fails to do <em class="markup--em markup--p-em">anything</em>. So don’t ship your app just yet. Test it.</p><div name="0beb" id="0beb" class="graf graf--mixtapeEmbed graf-after--p graf--trailing"><a href="https://medium.com/better-programming/beginning-python-programming-part-16-5703d8f0fad3" data-href="https://medium.com/better-programming/beginning-python-programming-part-16-5703d8f0fad3" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.com/better-programming/beginning-python-programming-part-16-5703d8f0fad3"><strong class="markup--strong markup--mixtapeEmbed-strong">Beginning Python Programming — Part 16</strong><br><em class="markup--em markup--mixtapeEmbed-em">Let’s talk about test driven development</em>medium.com</a><a href="https://medium.com/better-programming/beginning-python-programming-part-16-5703d8f0fad3" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="94c4b54c3b3bf8ef84ec11522efcb405" data-thumbnail-img-id="0*mPjWjj6RkWX7QzH9" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*mPjWjj6RkWX7QzH9);"></a></div></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@broebling" class="p-author h-card">Bob Roebling</a> on <a href="https://medium.com/p/ae96dd8b9c95"><time class="dt-published" datetime="2019-07-01T10:45:08.200Z">July 1, 2019</time></a>.</p><p><a href="https://medium.com/@broebling/beginning-python-programming-part-15-ae96dd8b9c95" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 1, 2019.</p></footer></article></body></html>