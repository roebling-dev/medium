<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Beginning Python Programming — Part 14</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Beginning Python Programming — Part 14</h1>
</header>
<section data-field="subtitle" class="p-summary">
An introduction to multi-threading
</section>
<section data-field="body" class="e-content">
<section name="32e9" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="5ce5" id="5ce5" class="graf graf--h3 graf--leading graf--title">Beginning Python Programming — Part 14</h3><h4 name="8c52" id="8c52" class="graf graf--h4 graf-after--h3 graf--subtitle">An introduction to multi-threading</h4></div><div class="section-inner sectionLayout--outsetColumn"><figure name="e1af" id="e1af" class="graf graf--figure graf--layoutOutsetCenter graf-after--h4"><div class="aspectRatioPlaceholder is-locked" style="max-width: 1032px; max-height: 774px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 75%;"></div><img class="graf-image" data-image-id="0*QOCJvi257uMJQh4X" data-width="5184" data-height="3888" data-unsplash-photo-id="U3sOwViXhkY" data-is-featured="true" src="https://cdn-images-1.medium.com/max/1200/0*QOCJvi257uMJQh4X"></div><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/@franckinjapan?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com/@franckinjapan?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-creator noopener noopener" target="_blank">Franck V.</a> on <a href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-source noopener noopener" target="_blank">Unsplash</a></figcaption></figure></div><div class="section-inner sectionLayout--insetColumn"><p name="73a3" id="73a3" class="graf graf--p graf-after--figure">In <a href="https://medium.com/better-programming/beginning-python-programming-part-13-6147ce4cd88d" data-href="https://medium.com/better-programming/beginning-python-programming-part-13-6147ce4cd88d" class="markup--anchor markup--p-anchor" target="_blank">part 13 of Beginning Python Programming</a>, we covered <code class="markup--code markup--p-code">asyncio</code> and just hit the surface of asynchronous code.</p><p name="5bf6" id="5bf6" class="graf graf--p graf-after--p">Today, we are going to keep moving in the direction of async by looking at another method called multi-threading. If you haven’t read the previous piece, I strongly suggest you read the introduction as a primer.</p><p name="a81a" id="a81a" class="graf graf--p graf-after--p">Let’s zoom out for a second and think about the big picture again.</p><ul class="postList"><li name="fb69" id="fb69" class="graf graf--li graf-after--p">Process — an individual program that runs to perform work. (e.g., Google Chrome, Firefox)</li><li name="4908" id="4908" class="graf graf--li graf-after--li">Thread — a worker <em class="markup--em markup--li-em">queue</em> to which a program sends tasks.</li><li name="e66a" id="e66a" class="graf graf--li graf-after--li">Thread Queue — a list of instructions that the processor will handle in a first-in-first-out (FIFO) way. (Think of a factory line)</li><li name="24fb" id="24fb" class="graf graf--li graf-after--li">Stack — all of the expressions you have called that will send an instruction to a thread queue. These are created in a last-in-first-out (LIFO) way. (Think of how you would tear down a tower of blocks one by one without knocking them down)</li><li name="0b3e" id="0b3e" class="graf graf--li graf-after--li">Memory Space — the space in memory that is used by a single process, all data stored in a memory space can be accessed by a process, and all of the threads the process owns.</li></ul><p name="356a" id="356a" class="graf graf--p graf-after--li graf--trailing">Let’s dive in.</p></div></div></section><section name="311c" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="5849" id="5849" class="graf graf--h3 graf--leading">Threading</h3><p name="1f6d" id="1f6d" class="graf graf--p graf-after--h3">While <code class="markup--code markup--p-code">asyncio</code> might be suitable for web servers, sometimes it is not the best tool for the job. If you refer back to the previous article, <code class="markup--code markup--p-code">asyncio</code> is useful for when you have many connections to multiple resources (aka web server routes). But what happens when you need a few connections to a single resource, such as manipulating files on a hard drive simultaneously?</p><p name="2ef1" id="2ef1" class="graf graf--p graf-after--p">Threads can share memory and resources because they belong to (are owned by) the same process.</p><p name="b6a9" id="b6a9" class="graf graf--p graf-after--p">Processes cannot share memory or resources because they belong to their own memory space. If you do need to share data between two processes, then you need to store this data in a database or a cache.</p><p name="8dd9" id="8dd9" class="graf graf--p graf-after--p">This is where the <code class="markup--code markup--p-code">threading</code> library comes in to play.</p><p name="f4ae" id="f4ae" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">threading</code> spawns processes on different threads. Not only can we use <code class="markup--code markup--p-code">threading</code> to perform simultaneous file manipulations, but we can also use it to perform multiple download requests or numerous API calls.</p><p name="d941" id="d941" class="graf graf--p graf-after--p">One more thing to cover before we go into an example is something called a <em class="markup--em markup--p-em">race condition</em>. Race conditions are when two separate processes or threads try to manipulate the same data at the same time. When this happens, one process may get unexpected data. If you read my previous article and ran the last example, you’d see a race condition in the console output. Some lines seemed to be merged. While it didn’t crash our program, in many situations your program will crash. When using the <code class="markup--code markup--p-code">threading</code> library, it is important that you keep track of what is being modified and when. If it helps, write it down on a sheet of paper.</p><p name="8895" id="8895" class="graf graf--p graf-after--p">Let’s look at a simple example:</p><figure name="7aca" id="7aca" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/mildocjr/794f4bf8006c286db34dd76cb9620818.js"></script></figure><p name="7bbf" id="7bbf" class="graf graf--p graf-after--figure">Here we import <code class="markup--code markup--p-code">threading</code> at the top of the file to use the library. Then we create a function that returns a list that contains every value between a <code class="markup--code markup--p-code">min</code> and <code class="markup--code markup--p-code">max</code> argument that we pass in. To better visualize this, we also include a <code class="markup--code markup--p-code">thread</code> argument where we will pass in the name of the thread that is currently running.</p><p name="00e6" id="00e6" class="graf graf--p graf-after--p">In our count function, we first print out that the thread has started. We create a <code class="markup--code markup--p-code">this_list</code> variable to hold our values in and initialize our <code class="markup--code markup--p-code">index</code> variable to 0.</p><p name="bfaa" id="bfaa" class="graf graf--p graf-after--p">We then loop through all of the values using our <code class="markup--code markup--p-code">min</code> and <code class="markup--code markup--p-code">max</code> values for the range and insert them into the array while incrementing our index. Then we print that the thread is completed before adding <code class="markup--code markup--p-code">my_list</code> the outer <code class="markup--code markup--p-code">result</code> variable for printing later.</p><p name="2370" id="2370" class="graf graf--p graf-after--p">Next, we create our two threads and provide each with a target of <code class="markup--code markup--p-code">count</code>. Target is what we want to do on this thread. Since <code class="markup--code markup--p-code">count</code> takes three arguments, we also pass in three arguments as a tuple to the <code class="markup--code markup--p-code">args</code> keyword.</p><p name="06ae" id="06ae" class="graf graf--p graf-after--p">This is where the two threads differ. One counts from zero to <em class="markup--em markup--p-em">ten million</em> while the other counts from zero to <em class="markup--em markup--p-em">one million</em>. In my testing, these were the ideal numbers to prove that these two threads run at the same time without taking too long to do it. Feel free to add or remove a zero from each if it is too quick or taking too long on your computer.</p><p name="0d36" id="0d36" class="graf graf--p graf-after--p">Just because we create the threads doesn’t mean they start, we have to call <code class="markup--code markup--p-code">start()</code> on each thread for it to run. This helps with race conditions. Sometimes you might want to enumerate all of the threads you need to use before starting them all at once (e.g. storing the threads in their own list then looping through the list calling start on each).</p><p name="be2b" id="be2b" class="graf graf--p graf-after--p">Finally, we use <code class="markup--code markup--p-code">thread.join()</code> to block the main queue to ensure we have our results. Then we print the length of the first list inside of our <code class="markup--code markup--p-code">results</code> list.</p><p name="47d5" id="47d5" class="graf graf--p graf-after--p graf--trailing">Please note that if you try to use multi-threading on single-core CPUs, you will not see a performance boost. Instead, you might see a performance drop from the overhead of a single processor trying to handle the synchronization of your async code.</p></div></div></section><section name="9976" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--outsetColumn"><figure name="870a" id="870a" class="graf graf--figure graf--layoutOutsetCenter graf--leading"><div class="aspectRatioPlaceholder is-locked" style="max-width: 1032px; max-height: 581px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 56.3%;"></div><img class="graf-image" data-image-id="0*CVNSPDBDu6AyKPxK" data-width="4608" data-height="2592" data-unsplash-photo-id="7RQf2X6aXXI" src="https://cdn-images-1.medium.com/max/1200/0*CVNSPDBDu6AyKPxK"></div><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/@les_photos_de_raph?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com/@les_photos_de_raph?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-creator noopener noopener" target="_blank">Raphaël Biscaldi</a> on <a href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-source noopener noopener" target="_blank">Unsplash</a></figcaption></figure></div><div class="section-inner sectionLayout--insetColumn"><h3 name="c174" id="c174" class="graf graf--h3 graf-after--figure">ThreadPoolExecutor</h3><p name="b5a1" id="b5a1" class="graf graf--p graf-after--h3">Sometimes you need to customize how many threads should be used for a task, such as limiting the number of concurrent threads that should be used over a series of tasks.</p><p name="c469" id="c469" class="graf graf--p graf-after--p">To illustrate this, look at the following example, which is just a refactor of the example above:</p><figure name="d9ae" id="d9ae" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/mildocjr/713166619d4f152651be6bb75b3678c9.js"></script></figure><p name="f7eb" id="f7eb" class="graf graf--p graf-after--figure">Here we end up creating four different threads to process the same data. I just decided to use loops to manage the complexity of re-writing the same code over and over again (DRY principle).</p><p name="c4e8" id="c4e8" class="graf graf--p graf-after--p">Let’s say we have multiple tasks that need to run on a background thread. Each of these tasks requires some preliminary information that must be completed before the respective task begins. A basic web crawler would be a great example.</p><p name="a2ee" id="a2ee" class="graf graf--p graf-after--p">On small websites, we might be able to get by with <code class="markup--code markup--p-code">threading</code> but on large sites, we definitely need to limit the number of threads we are using so we don’t run into performance issues. You can only go so fast.</p><p name="10df" id="10df" class="graf graf--p graf-after--p">Here is a refactor using <code class="markup--code markup--p-code">ThreadPoolExecutor</code> based on an example found <a href="https://tutorialedge.net/python/concurrency/python-threadpoolexecutor-tutorial/#example" data-href="https://tutorialedge.net/python/concurrency/python-threadpoolexecutor-tutorial/#example" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">here</a>:</p><figure name="3f8c" id="3f8c" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/mildocjr/35cd3ccc45078d01e0ee76316523c6b8.js"></script></figure><p name="5569" id="5569" class="graf graf--p graf-after--figure">We have a few more imports at the top. We include <code class="markup--code markup--p-code">threading</code> because we need to get the <code class="markup--code markup--p-code">active_count()</code> of threads when our program starts and we need to be able to figure out which thread we are currently using for our task. We include <code class="markup--code markup--p-code">time</code> because we want to calculate the run time of the application when we adjust how many threads we are using. Last, we use <code class="markup--code markup--p-code">from concurrent.futures import ThreadPoolExecutor</code> this allows us to import the <code class="markup--code markup--p-code">ThreadPoolExecutor</code> exclusively, instead of the entire <code class="markup--code markup--p-code">concurrent</code> library. This is what we will call to set up an executor later to run all of our tasks.</p><p name="7e4b" id="7e4b" class="graf graf--p graf-after--p">I start off creating a list of <code class="markup--code markup--p-code">numbers</code> that will contain values between 100,000 and 1,000,000 in increments of 10,000. We will use this to pass consistent values to each task between runs. I initially started off using <code class="markup--code markup--p-code">randint</code> from the <code class="markup--code markup--p-code">random</code> library, but realized that one run might get nothing but low values while another might get nothing but high values. This would skew our results.</p><p name="44c1" id="44c1" class="graf graf--p graf-after--p">We then create our <code class="markup--code markup--p-code">task</code>. This is similar to the count function above except we pass in the number we want to use as our max number. We let everyone know we started a task on a new thread and provide the name. Since the name is <code class="markup--code markup--p-code">ThreadPoolExecutor-x-y</code>, where <code class="markup--code markup--p-code">x</code> is the current thread pool and <code class="markup--code markup--p-code">y</code>is the current thread, I only use the last three values of the string.</p><p name="6ac1" id="6ac1" class="graf graf--p graf-after--p">We initialize <code class="markup--code markup--p-code">result</code> to 0 and start our loop to sum all of the numbers. We print the <code class="markup--code markup--p-code">result</code> before printing that the <code class="markup--code markup--p-code">current_thread()</code> has finished.</p><p name="365f" id="365f" class="graf graf--p graf-after--p">Our main function comes next. In it, we first create an <code class="markup--code markup--p-code">executor</code> object from <code class="markup--code markup--p-code">ThreadPoolExecutor</code> passing in the maximum number of workers we wish to use. We can also do this by using the named parameter <code class="markup--code markup--p-code">max_workers=10</code>. If you leave this blank, you end up with the number of processors on the machine multiplied by five. On my computer, I have 8 logical processors * 5 threads = 40 threads.</p><p name="e386" id="e386" class="graf graf--p graf-after--p">Normally, we’d call <code class="markup--code markup--p-code">executor.submit(task)</code> for each task, but in this scenario, we are passing a variable to the function, in this case, we are using <code class="markup--code markup--p-code">executor.map(task, numbers)</code> to do all of this work for us. What happens is the Interpreter first checks to get the length of <code class="markup--code markup--p-code">numbers</code> then for each number in <code class="markup--code markup--p-code">numbers</code> it passes the value to the <code class="markup--code markup--p-code">number</code> parameter of a <code class="markup--code markup--p-code">task</code>. Once it has finished, it will then submit the task using the <code class="markup--code markup--p-code">executor</code>.</p><p name="d3d2" id="d3d2" class="graf graf--p graf-after--p">We then have our <code class="markup--code markup--p-code">if __name__ == &quot;__main__”</code> statement, which checks to see if this file was invoked. When I initially created this program, I didn’t include the next line, which gets the current number of active threads, and my program never finished. When I printed the number of active threads, I found that I was already using three threads for this program.</p><p name="b3d5" id="b3d5" class="graf graf--p graf-after--p">Because of this, I needed to get the active number of threads so I could keep the program from running the time elapsed line at the bottom immediately. Think of this as a basic <a href="https://en.wikipedia.org/wiki/Semaphore_%28programming%29" data-href="https://en.wikipedia.org/wiki/Semaphore_(programming)" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">semaphore</a>, which is used for ensuring synchronization of multiple threads. Python has these built-in, but the example is more comfortable to digest this way.</p><p name="2052" id="2052" class="graf graf--p graf-after--p">Moving down, I get the current time so we have something to calculate the elapsed time against later. Then I call <code class="markup--code markup--p-code">main()</code> which kicks off the business logic of our application. Once all of the work is done, we determine the elapsed time in seconds and print it out to the screen.</p><p name="69b2" id="69b2" class="graf graf--p graf-after--p">After some testing with various numbers, I did some data science on the numbers to show a correlation between the number of threads used and the amount of time it took to run.</p></div><div class="section-inner sectionLayout--outsetColumn"><figure name="8a14" id="8a14" class="graf graf--figure graf--layoutOutsetCenter graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 1032px; max-height: 599px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 57.99999999999999%;"></div><img class="graf-image" data-image-id="1*xqK3Yx5fs524eHcav-x5IA.png" data-width="1382" data-height="802" src="https://cdn-images-1.medium.com/max/1200/1*xqK3Yx5fs524eHcav-x5IA.png"></div><figcaption class="imageCaption">Run times (in seconds) for the total number of threads used.</figcaption></figure></div><div class="section-inner sectionLayout--insetColumn"><p name="d07a" id="d07a" class="graf graf--p graf-after--figure">In the graph above, you can see how we start at six seconds to run the example above with one thread. As we increase the thread count, we quickly see our run time shrink. At four threads, we see a worse time, I ran this example several times to ensure there wasn’t an anomaly, and I kept getting consistent results. As we continued to increase the number of threads we saw steady boosts in milliseconds before leveling out between 10 and 30 threads.</p><p name="eacf" id="eacf" class="graf graf--p graf-after--p">Jumping up to 50, we see another boost, and at 100 threads, we see the best run time. Using 100 threads is not ideal, so we should back off and consider something in the range of 30 to 50.</p><p name="8cc3" id="8cc3" class="graf graf--p graf-after--p">Interesting enough, when we pass 1000 threads, our time got worse. The most likely reason for this is the amount of time it took to spin up all 1000 threads. More is not better in this situation.</p><p name="0bb0" id="0bb0" class="graf graf--p graf-after--p">Finally, I use the default number of worker threads by not passing in any number to <code class="markup--code markup--p-code">ThreadPoolExecutor()</code> , and we see 3.16 seconds. This is worse than 50 threads, but in our case, it seems to work out just fine.</p><p name="08db" id="08db" class="graf graf--p graf-after--p">Depending on how many thread pools I wanted to create, I might use 40–50 as a baseline for splitting up the number of worker threads. I’d also refer back to this graph to determine the best number of threads to use per pool. If I needed three pools, I might give each ten worker threads. If I used 12 pools, I might opt for three threads per pool instead of four because I had a better run time at three.</p><p name="e7e9" id="e7e9" class="graf graf--p graf-after--p graf--trailing">From another perspective, I could provide more threads to pools that require more work to be done and fewer to those that do basic tasks. I could also allocate threads by priority assigning more to tasks that the user has to wait on while tasks that run as daemons, or background tasks run with one or two threads. Referring to the chart above, I could use three threads for all of my background tasks while I could use 5 or 10 for all tasks initiated by the user. I’d need to ensure that I keep this under a more global limit which could either be 50 or 100.</p></div></div></section><section name="6256" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="774d" id="774d" class="graf graf--h3 graf--leading">Summary</h3><p name="cfab" id="cfab" class="graf graf--p graf-after--h3">We had an introduction to multi-threading in Python using the <code class="markup--code markup--p-code">threading</code> module and the <code class="markup--code markup--p-code">concurrent</code> module. We briefly looked at how to create and manage threads and how to wait on our threads to finish before continuing the execution of our program.</p><p name="03ca" id="03ca" class="graf graf--p graf-after--p">There are plenty more details about threading and thread pools that I didn’t cover here. I just wanted you to get your feet wet in threading, so you don’t feel lost while going through the documentation.</p><h4 name="5395" id="5395" class="graf graf--h4 graf-after--p">Suggested Reading</h4><p name="8871" id="8871" class="graf graf--p graf-after--h4">Threading from the Python docs.</p><div name="031c" id="031c" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://docs.python.org/3.7/library/threading.html" data-href="https://docs.python.org/3.7/library/threading.html" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://docs.python.org/3.7/library/threading.html"><strong class="markup--strong markup--mixtapeEmbed-strong">threading — Thread-based parallelism — Python 3.7.4rc1 documentation</strong><br><em class="markup--em markup--mixtapeEmbed-em">Return the ‘thread identifier’ of the current thread. This is a nonzero integer. Its value has no direct meaning; it is…</em>docs.python.org</a><a href="https://docs.python.org/3.7/library/threading.html" class="js-mixtapeImage mixtapeImage mixtapeImage--empty u-ignoreBlock" data-media-id="0266008713f29e864f0fbd4df2a3da8f"></a></div><p name="c083" id="c083" class="graf graf--p graf-after--mixtapeEmbed">Concurrent Futures from the Python docs. Don’t worry about Multi-processing just yet.</p><div name="6d7f" id="6d7f" class="graf graf--mixtapeEmbed graf-after--p graf--trailing"><a href="https://docs.python.org/3/library/concurrent.futures.html#module-concurrent.futures" data-href="https://docs.python.org/3/library/concurrent.futures.html#module-concurrent.futures" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://docs.python.org/3/library/concurrent.futures.html#module-concurrent.futures"><strong class="markup--strong markup--mixtapeEmbed-strong">concurrent.futures — Launching parallel tasks — Python 3.7.4rc1 documentation</strong><br><em class="markup--em markup--mixtapeEmbed-em">When using , this method chops iterables into a number of chunks which it submits to the pool as separate tasks. The…</em>docs.python.org</a><a href="https://docs.python.org/3/library/concurrent.futures.html#module-concurrent.futures" class="js-mixtapeImage mixtapeImage mixtapeImage--empty u-ignoreBlock" data-media-id="8326feb9277f5bbce32609bbda8e963c"></a></div></div></div></section><section name="2643" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="2023" id="2023" class="graf graf--h3 graf--leading">What’s Next?</h3><p name="4ccb" id="4ccb" class="graf graf--p graf-after--h3">Multi-processing is next. Multi-processing is like multi-threading except we use multiple cores to perform work. We will also cover differences between asyncio, threading, and multi-processing near the end. It is crucial to understand which one to use for each task. Until then, keep practicing.</p><div name="aeb3" id="aeb3" class="graf graf--mixtapeEmbed graf-after--p graf--trailing"><a href="https://medium.com/better-programming/beginning-python-programming-part-15-ae96dd8b9c95" data-href="https://medium.com/better-programming/beginning-python-programming-part-15-ae96dd8b9c95" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.com/better-programming/beginning-python-programming-part-15-ae96dd8b9c95"><strong class="markup--strong markup--mixtapeEmbed-strong">Beginning Python Programming — Part 15</strong><br><em class="markup--em markup--mixtapeEmbed-em">An introduction to multi-processing</em>medium.com</a><a href="https://medium.com/better-programming/beginning-python-programming-part-15-ae96dd8b9c95" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="a150138058772efe9e9b77e32e666b00" data-thumbnail-img-id="0*IyqUsB_yVwFp07kD" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*IyqUsB_yVwFp07kD);"></a></div></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@broebling" class="p-author h-card">Bob Roebling</a> on <a href="https://medium.com/p/208b9fa2f0a1"><time class="dt-published" datetime="2019-06-20T16:24:13.716Z">June 20, 2019</time></a>.</p><p><a href="https://medium.com/@broebling/beginning-python-programming-part-14-208b9fa2f0a1" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 1, 2019.</p></footer></article></body></html>